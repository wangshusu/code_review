# 计算机结构与M4体系结构



## 3. 各组件之间如何通信

总线: 多根"电线"
	总线有**两个特点 : **

* 1) 任意时刻只能有一个设备向总线发送信息。 ==> 系统瓶颈
* 2) 多个部件可以同时从总线上接收相同的信息。 ==> 广播式通信

把总线**按照功能分类:**

* 数据总线(DB)： 双向，宽度差别跟机器字长有关系
* 地址总线(AB):    单向，CPU发地址，宽度跟寻址空间有关
* 控制总线(CB):    发送命令和状态(读写信号、片选信号、中断响应等)

把总线**按照位置分类:**
* 片内总线: CPU内部连接各寄存器及运算器部件之间的总线
* 系统总线: CPU和内存、I/O设备等其他高速功能部件之间的总线
* 通信总线: (I/O总线): CPU和中低速I/O设备相互连接的总线



### 4. CPU工作原理

CPU的组成：

* ALU:  加法器==> 加、减(补码)、乘、除、取余

* Control Unit: 控制器

* Register(寄存器)
    * **寄存器**是CPU内部用来存放数据的一些小型的存储区域，用来暂时存放参与运算的数据和运算结果。
    * 寄存器实现就是一种常用的**时序逻辑电路**，只不过这种时序逻辑电路只包含存储电路。  **锁存器/触发器**



## 5. 几个基本概念

机器字长： 是指CPU一次能处理数据的位数，通常与CPU的寄存器位数有关。
			  字长越大，数的表示范围越大，精度也越高。

* int 与 机器字长的关系?
    	int  类型一般为机器中**最自然的长度**。
        	unsigned long  ==> **寻址范围**

* bit: 一个存储元件寄存一位二进制数据。  高电平/低电平
* Byte: 一个存储元件，包含8个bit。


芯片: CPU + 总线 + 各种硬件控制器..



### 6. Cortex M4 寄存器(CPU内部的寄存器)

* **通用寄存器**
    * R0~R7: thumb,thumb-2都可以访问
    * R8~R12: 只有少量的thumb指令可以访问，thumb-2可以访问

* **专用寄存器**： R13,R14,R15, xPSR
    * R13(SP): Stack Pointer 保存堆栈的栈顶地址。
        * **"堆栈"(Stack)是什么？**是用“栈的思想”来管理的一段内存。
            * "栈的思想": 先进后出，后进先出
        * **为什么需要“堆栈”？**为了支持过程(函数)调用。
            * "现场保护": 把寄存器里面的内容保存到内存中去。
            * "现场恢复": 把原先保存的内容还原到相应的寄存器中去。
        * Cortex M4 有两个堆栈，**双堆栈机制**
            * MSP  主堆栈指针
            * PSP  进程堆栈指针
        * **为什么需要双堆栈呢？**
            * 为了支持操作系统。把操作系统用的堆栈和用户线程用的堆栈分开。

* **R14(LR) ：** Linked Register 链接寄存器。

    在执行过程(函数)调用指令的时候，我们需要保存该指令的下一条指令的地址，因为这个地址，就我过程结束后，要返回的地址。

    有一个专门的寄存器，用来保存过程调用的返回地址。 ==> LR

```c++
BL func  ;./*
	BL带返回的跳转指令，把这条指令的下一条指令的地址赋值给LR。
    跳转：到指定的地方去取指令并执行。
```



* **R15(PC):** Program Counter 程序计数器。

    保存的是下一条要执行的指令的地址。

    我们可以通过改变PC的值来实现跳转。

    "指令按顺序执行" ==> 根据地址的变化可以知道执行指令的条数。

    **指令流水线:**

    ​		Cortex M4采用的是三级流水线(取指、译码、执行)

​	

* **xPSR:** Program Status Register 程序状态寄存器

    程序状态寄存器：保存程序运行过程中的一些状态，这些要保存的状态为三类：

    * 应用状态寄存器 APSR: 计算结果的标志

    ​		N Z C V Q

    * 中断状态寄存器 IPSR: 保存产生的中断的编号 Exception Number(8bits)

    * 执行状态寄存器 EPSR: 执行状态，如： Thumb/ARM...

    ==> 组合成一个32bits的xPSR,如图 (M3权威指南41页)

**注意：** 我们每一条执行的指令都可以影响这些状态标志位。

* N: 负数标志。 Negative is set to bit 31 of the result。

    如果N==1,表示上一个指令操作的结果为负数

* Z: Zero。零标志。

    结果所有bit位都为0，APSR.Z == 1，否则APSR.Z==0

* C: Carry 借位或进位标志。

    进位： 在加法运算时，产生了进位
    借位： 在减法运算时，没产生了借位。
    
    ADC, ADD, CMN  加法运算，如果产生了进位，则C=1,   否则C=0
    SBC,  SUB,  CMP  减法运算，如果产生了借位，则C=0，否则C=1

* V: overflow 溢出

    反映有符号数做加减运算所得结果是否溢出，如果运算结果超过当前运算位数所能表示的范围，则溢出，V=1，否则V=0。

    注意：在有符号数的运算中，进(借)位和溢出是两个完全不同的概念

* Q: 饱和标志 

    饱和计算： 通过将数据强制置为最大(最小)允许值，减少了数据畸变，当然畸变仍然是存在的，不过若数据没有超过最大范围太多，就不会有太大的问题。

    其实就是本来 9999 + 1 = 0;

    但是我要求他在某个约束范围内 999 + 1 = 999 这样误差就相对而言比较小

    ```c
    ADD  R0 ,R0 ,R1   ;R0 = R0+R1
    QADD R0 ,R0 ,R1   ;R0 = R0+R1 采用饱和计算
    ```

    

# ARM指令














## ARM指令的格式

```c++
<opcode>{code}{S}   <Rd>  ,<Rn>  {,<operand2>}
<> 必须要有的 {} 可选的
    
opcode :操作码,我们用指令助记符表示 如 MOVE LDR STR 等等
code   :执行指令的条件码 如 EQ NE 等等,不写就表示没有
S      :Status 表示该指令执行的结构是否影响 xPSR 寄存器的标志位
Rd	   :目标寄存器 结果寄存器
Rn	   :第一个操作数寄存区
operand2 :第二个源操作数,可以是寄存器,也可以是立即数
    
注:
	1.汇编指令不区分大小写
    2.行注释使用的是 ";" 符号
```



![image-20220809093040886](C:%5CUsers%5C%E9%98%BF%E4%B8%83%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20220809093040886.png)



## ARM 指令寻址方式

### 1. 立即寻址

 **(操作数后面的地址码就是操作数本身)**

```asciiarmor
MOVE R5 , #0xFF ; 把寄存器R5的值设置为0xFF
```

立即数规则 : 

​		立即数是用12位的空间来保存的 , 其中低 8 位存 "基数 x" , 高四位存放的是 "右移次数 y" 二表示的数是 k

```c++
k = x>>(y*2);	//基于32位的循环右移
```

1. 判断一个数是否符合8位位图的原则, 首先看这个数的二进制表示中1的个数是否不超过8个. 如果不超过8个, 再看这n个1(n<=8)是否能同时放到8个二进制位中, 如果可以放进去, 再看这八个二进制位是否可以循环右移偶数位得到我们欲使用的数. 如果可以, 则此数符合8位位图原理, 是合法的立即数. 否则, 不符合.

2. 无法表示的32位数, 只有通过逻辑或算术运算等其它途径获得了. 比如0xffffff00, 可以通过0x000000ff按位取反得到.

    或者还可以通过 : 
    ​	MOV  R5  ,#0x102  ;error
    ​	==>
    ​	LDR  R5  ,=0x102  ;right 用LDR伪指令实现给R5赋值为0x102

 eg:

```c++
判断以下数据是否为合法的立即数
	0x1F000000  ==>  x:0x1F  y:0x04
	0x1FF       ==>  error
	0x101       ==>  error
	0x104       ==>  x:0x41  y:0x0F
	0x102       ==>  error
```




### 2.寄存器寻址

**(操作数存放在寄存器中 , 执行的时候去取寄存器的数据 , 不涉及内存)**

```c++
MOV R5	,R7		;把R7的数据存放到R5
SUB R5	,R5  R4	;R5 =R5 - R4
```



### 3.寄存器间接寻址

**(寄存器中存放的不是数据本身 , 而是数据的内存地址)**

```c++
LDR{cond}{S}{B/H}   Rd ,[Rn]
STR{cond}{S}{B/H}   Rd ,[Rn]
    cond: 条件码
        B: Byte一个字节， H: Half word 半字（两个字节）
        S: Signed 把地址的那个变量，当做是一个有符号的数据。
            如果没有S就把地址对应的那个变量，当做无符号的。
            
            当从内存中加载到寄存器中没有4个字节时，高位需要补数据。			有符号： 高位补符号位
            无符号： 高位补0
            
//取出R5的值，把这个值作为地址，再到该地址处把数据取出存放到R3
LDR  R3 ,[R5] ；
//取出R5的值，把这个值作为地址，把R3的值保存到该地址处
STR  R3 ,[R5] ；
//取出R5的值，把这个值作为地址，再到该地址处取两个字节存放到R3
LDRH  R3 ,[R5] ；
```



### 4.寄存器偏移寻址

(第二操作数是寄存器的位移方式，在执行命令之前先位移)

```c++
MOV  R3 ,R2 ,LSL #3   ; R3 = R2<<3
注: LSL 逻辑左移   LSR逻辑右移   ASR算术右移   ROR循环右移
```



### 5. 基址变址寻址

(将寄存器的内容与给出的偏移量相加形成操作数的地址，使可以访问基址附近的单位)

```c++
LDR  R0  ,[R1,#4]     ; R0 = [R1+4]
LDR  R0  ,[R1,R2]     ; R0 = [R1+R2]
LDR  R0  ,[R1,#4]!    ; 先 R0=[R1+4] 然后 R1=R1+4
LDR  R0  ,[R1],#4     ; 先 R0=[R1] 然后 R1=R1+4
```



### 6. 多寄存器寻址

(一次可以取出多个数据 Multiple)

```c++
//将R1指向地址的数据，依次写到R2-R7,R12中，且R1的值会变
LDMIA  R1!  ,{R2-R7,R12};
//将寄存器R2-R7,R12的值保存到R0指向的存储单元中，且R0的值会变
STMIA  R0!  ,{R2-R7,R12};

注：寄存器列表用“,”隔开，寄存器由小到大排列，连接的寄存器可以用“-”表示
    IA ：increase after  每次传送后地址加4
    IB ：increase before 每次传送前地址加4
    DA ：decrease after  每次传送后地址减4
    DB ：decrease before 每次传送前地址减4
```



### 7. 堆栈寻址： 先进后出

```c++
堆栈按照入栈时，栈顶的变化可以分为： 减栈和增栈
	减栈： 入栈时地址向下增长
	增栈： 入栈时地址向上增长
堆栈按照栈顶是否存放数据可以分为： 满栈和空栈
	满栈： SP指向的空间有存放数据
	空栈： SP指向的空间没有存放数据

	F:full         E:empty
	D:decrease     A:add

		POP     PUSH
满减栈  LDMFD   STMFD
满增栈  LDMFA   STMFA
空减栈  LDMED   STMED
空增栈  LDMEA   STMEA

注： ARM为满减栈

STMFD  SP! ,{R2-R7,LR} ;把R2-R7,LR的值压栈，栈顶是SP指向的地址
LDMFD  SP! ,{R2-R7,PC} ;把SP弹栈，值保存到R2-R7,PC
```

* 在调用子程序(函数)时，子程序间通过寄存器R0-R3来传递参数。
* 在子程序中，使用R4-R12来保存局部变量。
* 如果在子程序中使用了寄存器R4-R12中的某些寄存器，在子程序进入时必须要保护这些寄存器的值(现场保护)，并在返回前需要恢复(现场恢复)。



### 8.相对寻址

```c++
//没有写出具体的地址，根据给定的条件，编译的时候自动计算出地址
  	_wait
  		MOV  R0 ,#1
  		MOV  R1 ,#2
  		B    _wait
```



## ARM 指令操作

```c++
(1)跳转指令 

		不带返回的跳转：
			B  lable   ; 把lable的值赋值给PC
		带返回的跳转：
			BL lable   ; 先把PC-4(基于三级流水)的值赋值给LR，然后再把lable的值赋值给PC

		★BL 可以实现函数调用功能
		★B 往前跳可以实现循环结构，往后跳可以实现  if 和 if-else结构

	另外的方式实现跳转:
		MOV  PC, LR  ;函数返回

	(2) 数据处理指令(加减法，与或运算，赋值，比较)
	注：数据处理指令只能对寄存器R0~R15操作，不能对内存进行操作

		a. 数据传送指令 MOVEQS
			助记符              说明        操作             条件码位置
			MOV  Rd, operand   数据传送    Rd <- opreand     MOV{cond}{S}
			MVN  Rd, operand   数据非传送  Rd <- (~opreand)  MVN{cond}{S}

		eg:
			MOV   R0  ,#0xFF
			MVN   R0  ,#0xFF    ; R0 == 0xFFFFFF00
			MOV   R0  ,R1  ,LSL #2   ; R0 = R1<<2

		b. 比较指令(一定会影响标志位)
			CMP  Rn  ,operand  比较指令(大小)
			CMP  R0  ,#100     ;将寄存器R0的值与100相减，结果影响标志位

			CMN  Rn  ,operand  负数比较指令
			CMN  R0  ,#100     ;将寄存器R0的值与100相加，结果影响标志位

			TST  Rn  ,operand  位测试指令
			TST  R0  ,#100     ;将寄存器R0的值与100进行位与，结果影响标志位

			TEQ  Rn  ,operand  相等测试指令
			TEQ  R0  ,#100     ;将寄存器R0的值与100进行异或，结果影响标志位

		c. 运算指令{cond}{S}

			ADD  Rd  ,Rn  operand2  加法指令
			ADC  Rd  ,Rn  operand2  带进位加法(计算结果加上C标志位)

			SUB  Rd  ,Rn  operand2  减法指令
			SBC  Rd  ,Rn  operand2  带借位减法
			RSB  Rd  ,Rn  operand2  逆向减法
			RSC  Rd  ,Rn  operand2  带借位的逆向减法

			eg:
				ADDNE  R0 ,R1 ,R2  ;条件执行， R0 = R1+R2
				SUBS   R0 ,R1 ,R2  ;R0 = R1-R2 结果影响标志位
				RSB    R0 ,R1 ,#5  ;R0 = 5-R1
```

