# C++面试面经

### 1.1 语言基础

#### 1.1.1 简述下C++语言的特点

**参考回答**

1. C++在C语言基础上引入了**面对对象**的机制，同时也**兼容C语言**。
2. C++有三大特性（1）封装。（2）继承。（3）多态；
3. C++语言编写出的程序结构清晰、易于扩充，程序**可读性好**。
4. C++生成的代码**质量高**，运行**效率高**，仅比汇编语言慢10%～20%；
5. C++更加安全，增加了const常量、引用、四类cast转换（static_cast、dynamic_cast、const_cast、reinterpret_cast）、智能指针、try—catch等等；
6. C++**可复用性**高，C++引入了**模板**的概念，后面在此基础上，实现了方便开发的标准模板库STL（Standard Template Library）。
7. 同时，C++是**不断在发展**的语言。C++后续版本更是发展了不少新特性，如C++11中引入了nullptr、auto变量、Lambda匿名函数、右值引用、智能指针。

#### 1.1.2 说说C语言和C++的区别

**参考回答**

1. C语言是C++的子集，C++可以很好兼容C语言。但是C++又有很多**新特性**，如引用、智能指针、auto变量等。
2. C++是**面对对象**的编程语言；C语言是**面对过程**的编程语言。
3. C语言有一些不安全的语言特性，如指针使用的潜在危险、强制转换的不确定性、内存泄露等。而C++对此增加了不少新特性来**改善安全性**，如const常量、引用、cast转换、智能指针、try—catch等等；
4. C++**可复用性**高，C++引入了**模板**的概念，后面在此基础上，实现了方便开发的标准模板库STL。C++的STL库相对于C语言的函数库**更灵活、更通用**。

#### 1.1.3 说说 C++中 struct 和 class 的区别

**参考回答**

1. struct 一般用于描述一个数据结构集合，而 class 是对一个对象数据的封装；

2. struct 中默认的访问控制权限是 public 的，而 class 中默认的访问控制权限是 private 的，例如：

    ```
    struct A{  int iNum; // 默认访问控制权限是 public } class B{  int iNum; // 默认访问控制权限是 private }
    ```

3. 在继承关系中，struct 默认是公有继承，而 class 是私有继承；

4. class 关键字可以用于定义模板参数，就像 typename，而 struct 不能用于定义模板参数，例如：

    ```
    template<typename T, typename Y> // 可以把typename 换成 class  int Func(const T& t, const Y& y) {      //TODO  }
    ```

**答案解析**

1. C++ 中的 struct 是对 C 中的 struct 进行了扩充，它们在声明时的区别如下：

    |          |           C            |           C++            |
    | :------- | :--------------------: | :----------------------: |
    | 成员函数 |         不能有         |           可以           |
    | 静态成员 |         不能有         |           可以           |
    | 访问控制 |  默认public，不能修改  | public/private/protected |
    | 继承关系 |       不可以继承       | 可从类或者其他结构体继承 |
    | 初始化   | 不能直接初始化数据成员 |           可以           |

2. 使用时的区别：C 中使用结构体需要加上 struct 关键字，或者对结构体使用 typedef 取别名，而 C++ 中可以省略 struct 关键字直接使用，例如：

    ```
    struct Student{  int  iAgeNum;  string strName; } typedef struct Student Student2; //C中取别名  struct Student stu1; // C 中正常使用 Student2 stu2;   // C 中通过取别名的使用 Student stu3;   // C++ 中使用
    ```

#### 1.1.4 说说include头文件的顺序以及双引号""和尖括号<>的区别

**参考回答**

1. 区别：

    （1）尖括号<>的头文件是**系统文件**，双引号""的头文件是**自定义文件**。

    （2）编译器预处理阶段查找头文件的路径不一样。

2. 查找路径：

    （1）使用尖括号<>的头文件的查找路径：编译器设置的头文件路径-->系统变量。

    （2）使用双引号""的头文件的查找路径：当前头文件目录-->编译器设置的头文件路径-->系统变量。

#### 1.1.5 说说C++结构体和C结构体的区别

**参考回答**

区别：

（1）C的结构体内不允许有函数存在，C++允许有内部成员函数，且允许该函数是虚函数。

（2）C的结构体对内部成员变量的访问权限只能是public，而C++允许public,protected,private三种。

（3）C语言的结构体是不可以继承的，C++的结构体是可以从其他的结构体或者类继承过来的。

（4）C 中使用结构体需要加上 struct 关键字，或者对结构体使用 typedef 取别名，而 C++ 中可以省略 struct 关键字直接使用。

**答案解析**

1. C++ 中的 struct 是对 C 中的 struct 进行了扩充，它们在声明时的区别如下：

    |          |           C            |           C++            |
    | :------- | :--------------------: | :----------------------: |
    | 成员函数 |         不能有         |           可以           |
    | 静态成员 |         不能有         |           可以           |
    | 访问控制 |  默认public，不能修改  | public/private/protected |
    | 继承关系 |       不可以继承       | 可从类或者其他结构体继承 |
    | 初始化   | 不能直接初始化数据成员 |           可以           |

2. 使用时的区别：C 中使用结构体需要加上 struct 关键字，或者对结构体使用 typedef 取别名，而 C++ 中可以省略 struct 关键字直接使用，例如：

    ```
    struct Student{  int  iAgeNum;  string strName; } typedef struct Student Student2; //C中取别名  struct Student stu1; // C 中正常使用 Student2 stu2;   // C 中通过取别名的使用 Student stu3;   // C++ 中使用
    ```

#### 1.1.6 导入C函数的关键字是什么，C++编译时和C有什么不同？

**参考回答**

1. **关键字：**在C++中，导入C函数的关键字是**extern**，表达形式为**extern “C”**， extern "C"的主要作用就是为了能够正确实现C++代码调用其他C语言代码。加上extern "C"后，会指示编译器这部分代码按**C语言**的进行编译，而不是C++的。
2. **编译区别：**由于C++支持函数重载，因此编译器编译函数的过程中会将函数的**参数类型**也加到编译后的代码中，而不仅仅是**函数名**；而C语言并不支持函数重载，因此编译C语言代码的函数时不会带上函数的参数类型，一般只包括**函数名**。

**答案解析**

```C++
//extern示例 //在C++程序里边声明该函数，会指示编译器这部分代码按C语言的进行编译 extern "C" int strcmp(const char *s1, const char *s2);  //在C++程序里边声明该函数 extern "C"{     #include <string.h>//string.h里边包含了要调用的C函数的声明 }  //两种不同的语言，有着不同的编译规则，比如一个函数fun，可能C语言编译的时候为_fun，而C++则是__fun__
```

#### 1.1.7 简述C++从代码到可执行二进制文件的过程

**参考回答**

​    C++和C语言类似，一个C++程序从源码到执行文件，有四个过程，**预编译、编译、汇编、链接**。

**答案解析**

1. 预编译：这个过程主要的处理操作如下：

    （1） 将所有的#define删除，并且展开所有的宏定义

    （2） 处理所有的条件预编译指令，如#if、#ifdef

    （3） 处理#include预编译指令，将被包含的文件插入到该预编译指令的位置。

    （4） 过滤所有的注释

    （5） 添加行号和文件名标识。

2. 编译：这个过程主要的处理操作如下：

    （1） 词法分析：将源代码的字符序列分割成一系列的记号。

    （2） 语法分析：对记号进行语法分析，产生语法树。

    （3） 语义分析：判断表达式是否有意义。

    （4） 代码优化：

    （5） 目标代码生成：生成汇编代码。

    （6） 目标代码优化：

3. 汇编：这个过程主要是将汇编代码转变成机器可以执行的指令。

4. 链接：将不同的源文件产生的目标文件进行链接，从而形成一个可以执行的程序。

    链接分为静态链接和动态链接。

    静态链接，是在链接的时候就已经把要调用的函数或者过程链接到了生成的可执行文件中，就算你在去把静态库删除也不会影响可执行程序的执行；生成的静态链接库，Windows下以.lib为后缀，Linux下以.a为后缀。

    而动态链接，是在链接的时候没有把调用的函数代码链接进去，而是在执行的过程中，再去找要链接的函数，生成的可执行文件中没有函数代码，只包含函数的重定位信息，所以当你删除动态库时，可执行程序就不能运行。生成的动态链接库，Windows下以.dll为后缀，Linux下以.so为后缀。

#### 1.1.8 说说 static关键字的作用

**参考回答**

1. **定义全局静态变量和局部静态变量**：在变量前面加上static关键字。初始化的静态变量会在数据段分配内存，未初始化的静态变量会在BSS段分配内存。直到程序结束，静态变量始终会维持前值。只不过全局静态变量和局部静态变量的作用域不一样；

2. **定义静态函数**：在函数返回类型前加上static关键字，函数即被定义为静态函数。静态函数只能在**本源文件**中使用；

3. 在变量类型前加上static关键字，变量即被定义为静态变量。**静态变量只能在本源文件中使用**；

    ```C++
    //示例 static int a; static void func();
    ```

4. 在c++中，**static关键字可以用于定义类中的静态成员变量**：使用静态数据成员，它既可以被当成全局变量那样去存储，但又被隐藏在类的内部。类中的static静态数据成员拥有一块单独的存储区，而不管创建了多少个该类的对象。所有这些对象的静态数据成员都**共享**这一块静态存储空间。

5. 在c++中，**static关键字可以用于定义类中的静态成员函数**：与静态成员变量类似，类里面同样可以定义静态成员函数。只需要在函数前加上关键字static即可。如静态成员函数也是类的一部分，而不是对象的一部分。所有这些对象的静态数据成员都**共享**这一块静态存储空间。

**答案解析**

当调用一个对象的非静态成员函数时，系统会把该对象的起始地址赋给成员函数的this指针。而静态成员函数不属于任何一个对象，因此C++规定静态成员函数没有this指针（划重点，面试题常考）。既然它没有指向某一对象，也就无法对一个对象中的非静态成员进行访问。

#### 1.1.9 说说数组和指针的区别

**参考回答**

1. 概念：

    （1）数组：数组是用于储存多个相同类型数据的集合。 数组名是首元素的地址。 

    （2）指针：指针相当于一个变量，但是它和不同变量不一样，它存放的是其它变量在**内存中的地址**。 指针名指向了内存的首地址。 

2. 区别：

    （1）**赋值**：同类型指针变量可以相互赋值；数组不行，只能一个一个元素的赋值或拷贝

    （2）**存储方式**：

      数组：数组在内存中是连续存放的，开辟一块连续的内存空间。数组是根据数组的下进行访问的，数组的存储空间，不是在静态区就是在栈上。

      指针：指针很灵活，它可以指向任意类型的数据。指针的类型说明了它所指向地址空间的内存。由于指针本身就是一个变量，再加上它所存放的也是变量，所以指针的存储空间不能确定。

    （3）**求sizeof**：

      数组所占存储空间的内存大小：sizeof（数组名）/sizeof（数据类型）

      在32位平台下，无论指针的类型是什么，sizeof（指针名）都是4，在64位平台下，无论指针的类型是什么，sizeof（指针名）都是8。

    （4）**初始化**：

    ```C++
    // 数组 int a[5] = { 0 }; char b[] = "Hello"; // 按字符串初始化，大小为6 char c[] = { 'H','e','l','l','o','\0' }; // 按字符初始化 int* arr = new int[10]; // 动态创建一维数组  // 指针 // 指向对象的指针 int* p = new int(0); delete p; // 指向数组的指针 int* p1 = new int[10]; delete[] p1; // 指向类的指针： string* p2 = new string; delete p2; // 指向指针的指针（二级指针） int** pp = &p; **pp = 10;
    ```

    （5）指针操作： 

      数组名的指针操作

    ```C++
    int a[3][4];   int (*p)[4];  //该语句是定义一个数组指针，指向含4个元素的一维数组 p = a;    //将该二维数组的首地址赋给p，也就是a[0]或&a[0][0] p++;          //该语句执行过后，也就是p=p+1；p跨过行a[0][]指向了行a[1][]               //所以数组指针也称指向一维数组的指针，亦称行指针。 //访问数组中第i行j列的一个元素，有几种操作方式： //*(p[i]+j)、*(*(p+i)+j)、(*(p+i))[j]、p[i][j]。其中，优先级：()>[]>*。 //这几种操作方式都是合法的。
    ```

    指针变量的数据操作：

    ```C++
    char *str = "hello,douya!";
    str[2] = 'a';
    *(str+2) = 'b';
    //这两种操作方式都是合法的。
    ```

#### 1.1.10 说说什么是函数指针，如何定义函数指针，有什么使用场景

**参考回答**

1. **概念：**函数指针就是**指向函数**的指针变量。每一个函数都有一个入口地址，该入口地址就是函数指针所指向的地址。
2. **定义**形式如下：

```C++
int func(int a);  
int (*f)(int a);  
f = &func;  
```

1. 函数指针的**应用场景**：**回调**（callback）。我们调用别人提供的 API函数(Application Programming Interface,应用程序编程接口)，称为Call；如果别人的库里面调用我们的函数，就叫Callback。

**答案解析**

```C++
//以库函数qsort排序函数为例，它的原型如下：
void qsort(void *base,//void*类型，代表原始数组
           size_t nmemb, //第二个是size_t类型，代表数据数量
           size_t size, //第三个是size_t类型，代表单个数据占用空间大小
           int(*compar)(const void *,const void *)//第四个参数是函数指针
          );C++
//第四个参数告诉qsort，应该使用哪个函数来比较元素，即只要我们告诉qsort比较大小的规则，它就可以帮我们对任意数据类型的数组进行排序。在库函数qsort调用我们自定义的比较函数，这就是回调的应用。

//示例
int num[100];
int cmp_int(const void* _a , const void* _b){//参数格式固定
    int* a = (int*)_a;    //强制类型转换
    int* b = (int*)_b;
    return *a - *b;　　
}
qsort(num,100,sizeof(num[0]),cmp_int); //回调
```

#### 1.1.11 说说静态变量什么时候初始化？

**参考回答**

对于C语言的全局和静态变量，初始化发生在任何代码执行之前，属于编译期初始化。

而C++标准规定：全局或静态对象当且仅当对象首次用到时才进行构造。

**答案解析**

1. **作用域**：C++里作用域可分为6种：全局，局部，类，语句，命名空间和文件作用域。

    静态全局变量 ：全局作用域+文件作用域，所以无法在其他文件中使用。

    静态局部变量 ：局部作用域，只被初始化一次，直到程序结束。

    类静态成员变量：类作用域。

2. **所在空间**：都在静态存储区。因为静态变量都在静态存储区，所以下次调用函数的时候还是能取到原来的值。

3. **生命周期**：静态全局变量、静态局部变量都在静态存储区，直到程序结束才会回收内存。类静态成员变量在静态存储区，当超出类作用域时回收内存。

#### 1.1.12 nullptr调用成员函数可以吗？为什么？

**参考回答**

能。

原因：因为在**编译时对象**就绑定了**函数地址**，和指针空不空没关系。

**答案解析**

```C++
//给出实例
class animal{
public:
    void sleep(){ cout << "animal sleep" << endl; }
    void breathe(){ cout << "animal breathe haha" << endl; }
};
class fish :public animal{
public:
    void breathe(){ cout << "fish bubble" << endl; }
};
int main(){
    animal *pAn=nullptr;
    pAn->breathe();   // 输出：animal breathe haha
    fish *pFish = nullptr;
    pFish->breathe(); // 输出：fish bubble
    return 0;
}  
```

原因：因为在**编译时对象**就绑定了**函数地址**，和指针空不空没关系。pAn->breathe();编译的时候，函数的地址就和指针pAn绑定了；调用breath(*this), this就等于pAn。由于函数中没有需要解引用this的地方，所以函数运行不会出错，但是若用到this，因为this=nullptr，运行出错。

#### 1.1.13 说说什么是野指针，怎么产生的，如何避免？

**参考回答**

1. **概念：**野指针就是指针指向的位置是不可知的（随机的、不正确的、没有明确限制的）

2. **产生原因**：释放内存后指针不及时置空（野指针），依然指向了该内存，那么可能出现非法访问的错误。这些我们都要注意避免。

3. **避免办法：**

    （1）初始化置NULL

    （2）申请内存后判空

    （3）指针释放后置NULL

    （4）使用智能指针

**答案解析**

**产生原因**：释放内存后指针不及时置空（野指针），依然指向了该内存，那么可能出现非法访问的错误。这些我们都要注意避免。如：

```C++
char *p = (char *)malloc(sizeof(char)*100);  
strcpy(p, "Douya");  
free(p);//p所指向的内存被释放，但是p所指的地址仍然不变  
...  
if (p != NULL){//没有起到防错作用  
    strcpy(p, "hello, Douya!");//出错  
}  
```

**避免办法：**

（1）初始化置NULL

（2）申请内存后判空

（3）指针释放后置NULL

```C++
int *p = NULL; //初始化置NULL
p = (int *)malloc(sizeof(int)*n); //申请n个int内存空间  
assert(p != NULL); //判空，防错设计
p = (int *) realloc(p, 25);//重新分配内存, p 所指向的内存块会被释放并分配一个新的内存地址
free(p);  
p = NULL; //释放后置空

int *p1 = NULL; //初始化置NULL
p1 = (int *)calloc(n, sizeof(int)); //申请n个int内存空间同时初始化为0 
assert(p1 != NULL); //判空，防错设计
free(p1);  
p1 = NULL; //释放后置空

int *p2 = NULL; //初始化置NULL
p2 = new int[n]; //申请n个int内存空间  
assert(p2 != NULL); //判空，防错设计
delete []p2;  
p2 = nullptr; //释放后置空  
```

#### 1.1.14 说说静态局部变量，全局变量，局部变量的特点，以及使用场景

**参考回答**

1. **首先从作用域考虑**：C++里作用域可分为6种：全局，局部，类，语句，命名空间和文件作用域。

    全局变量：全局作用域，可以通过extern作用于其他非定义的源文件。

    静态全局变量 ：全局作用域+文件作用域，所以无法在其他文件中使用。

    局部变量：局部作用域，比如函数的参数，函数内的局部变量等等。

    静态局部变量 ：局部作用域，只被初始化一次，直到程序结束。

2. **从所在空间考虑**：除了局部变量在栈上外，其他都在静态存储区。因为静态变量都在静态存储区，所以下次调用函数的时候还是能取到原来的值。

3. **生命周期**： 局部变量在栈上，出了作用域就回收内存；而全局变量、静态全局变量、静态局部变量都在静态存储区，直到程序结束才会回收内存。

4. **使用场景**：从它们各自特点就可以看出各自的应用场景，不再赘述。

#### 1.1.15 说说内联函数和宏函数的区别

**参考回答**

区别：

1. **宏定义不是函数**，但是使用起来像函数。预处理器用复制宏代码的方式代替函数的调用，省去了函数压栈退栈过程，提高了效率；**而内联函数本质上是一个函数**，内联函数一般用于函数体的代码比较简单的函数，不能包含复杂的控制语句，while、switch，并且内联函数本身不能直接调用自身。
2. **宏函数**是在预编译的时候把所有的宏名用宏体来替换，简单的说就是字符串替换 ；**而内联函数**则是在编译的时候进行代码插入，编译器会在每处调用内联函数的地方直接把内联函数的内容展开，这样可以省去函数的调用的开销，提高效率
3. **宏定义**是没有类型检查的，无论对还是错都是直接替换；**而内联函数**在编译的时候会进行类型的检查，内联函数满足函数的性质，比如有返回值、参数列表等

**答案解析**

```C++
//宏定义示例
#define MAX(a, b) ((a)>(b)?(a):(b))
MAX(a, "Hello"); //错误地比较int和字符串，没有参数类型检查

//内联函数示例
#include <stdio.h>
inline int add(int a, int b) {
    return (a + b);
}
int main(void) {
    int a;
    a = add(1, 2);
    printf("a+b=%d\n", a);
    return 0;
}
//以上a = add(1, 2);处在编译时将被展开为：a = (a + b);
```

**1、使用时的一些注意事项：**

- 使用宏定义一定要注意错误情况的出现，比如宏定义函数没有类型检查，可能传进来任意类型，从而带来错误，如举例。还有就是括号的使用，宏在定义时要小心处理宏参数，一般用括号括起来，否则容易出现二义性
- inline函数一般用于比较小的，频繁调用的函数，这样可以减少函数调用带来的开销。只需要在函数返回类型前加上关键字inline，即可将函数指定为inline函数。
- 同其它函数不同的是，最好将inline函数定义在头文件，而不仅仅是声明，因为编译器在处理inline函数时，需要在调用点内联展开该函数，所以仅需要函数声明是不够的。

**2、内联函数使用的条件：**

- 内联是以代码膨胀（复制）为代价，仅仅省去了函数调用的开销，从而提高函数的执行效率。如果执行函数体内代码的时间，相比于函数调用的开销较大，那么效率 的收获会很少。另一方面，每一处内联函数的调用都要复制代码，将使程序的总代码量增大，消耗更多的内存空间。以下情况不宜使用内联：
- （1）如果函数体内的代码比较长，使用内联将导致内存消耗代价较高。
- （2）如果函数体内出现循环，那么执行函数体内代码的时间要比函数调用的开销大。
- 内联不是什么时候都能展开的，一个好的编译器将会根据函数的定义体，自动地取消不符合要求的内联。

#### 1.1.16 说说运算符i++和++i的区别

**参考回答**

**先看到实现代码：** 

```C++
#include <stdio.h>
int main(){
       int i = 2;
    int j = 2;
    j += i++; //先赋值后加
    printf("i= %d, j= %d\n",i, j); //i= 3, j= 4
    i = 2;
    j = 2;
    j += ++i; //先加后赋值
    printf("i= %d, j= %d",i, j); //i= 3, j= 5
}
```

1. **赋值顺序不同**：++ i 是先加后赋值；i ++ 是先赋值后加；++i和i++都是分两步完成的。

2. **效率不同**：后置++执行速度比前置的慢。

3. **i++ 不能作为左值，而++i 可以**：

    ```C++
    int i = 0;
    int* p1 = &(++i);//正确
    // int* p2 = &(i++);//错误
    ++i = 1;//正确
    // i++ = 1;//错误
    ```

4. 两者都不是原子操作。

#### 1.1.17 说说new和malloc的区别，各自底层实现原理。

**参考回答**

1. new是操作符，而malloc是函数。
2. new在调用的时候先分配内存，在调用构造函数，释放的时候调用析构函数；而malloc没有构造函数和析构函数。
3. malloc需要给定申请内存的大小，返回的指针需要强转；new会调用构造函数，不用指定内存的大小，返回指针不用强转。
4. new可以被重载；malloc不行
5. new分配内存更直接和安全。
6. new发生错误抛出异常，malloc返回null

**答案解析**

**malloc底层实现：**当开辟的空间小于 128K 时，调用 brk（）函数；当开辟的空间大于 128K 时，调用mmap（）。malloc采用的是内存池的管理方式，以减少内存碎片。先申请大块内存作为堆区，然后将堆区分为多个内存块。当用户申请内存时，直接从堆区分配一块合适的空闲快。采用隐式链表将所有空闲块，每一个空闲块记录了一个未分配的、连续的内存地址。

**new底层实现：**关键字new在调用构造函数的时候实际上进行了如下的几个步骤：

1. 创建一个新的对象
2. 将构造函数的作用域赋值给这个新的对象（因此this指向了这个新的对象）
3. 执行构造函数中的代码（为这个新对象添加属性）
4. 返回新对象

#### 1.1.18 说说const和define的区别。

**参考回答**

const用于定义常量；而define用于定义宏，而宏也可以用于定义常量。都用于常量定义时，它们的区别有：

1. const生效于编译的阶段；define生效于预处理阶段。
2. const定义的常量，在C语言中是存储在内存中、需要额外的内存空间的；define定义的常量，运行时是直接的操作数，并不会存放在内存中。
3. const定义的常量是带类型的；define定义的常量不带类型。因此define定义的常量不利于类型检查。

#### 1.1.19 说说C++中函数指针和指针函数的区别。

**参考回答**

1. **定义不同** 指针函数本质是一个函数，其返回值为指针。 函数指针本质是一个指针，其指向一个函数。

2. **写法不同**

    ```C++
    指针函数：int *fun(int x,int y);
    函数指针：int (*fun)(int x,int y);
    ```

3. **用法不同**

    用法参考答案解析

**答案解析**

```C++
//指针函数示例
typedef struct _Data{
    int a;
    int b;
}Data;
//指针函数
Data* f(int a,int b){
    Data * data = new Data;
    //...
    return data;
}
int main(){
    //调用指针函数
    Data * myData = f(4,5);
    //Data * myData = static_cast<Data*>(f(4,5));
   //...
}

//函数指针示例
int add(int x,int y){
    return x+y;
}
//函数指针
int (*fun)(int x,int y);
//赋值
fun = add;
//调用
cout << "(*fun)(1,2) = " << (*fun)(1,2) ;
//输出结果
//(*fun)(1,2) =  3
```

#### 1.1.20 说说const int *a, int const *a, const int a, int *const a, const int *const a分别是什么，有什么特点。

**参考回答**

```C++
1. const int a;     //指的是a是一个常量，不允许修改。
2. const int *a;    //a指针所指向的内存里的值不变，即（*a）不变
3. int const *a;    //同const int *a;
4. int *const a;    //a指针所指向的内存地址不变，即a不变
5. const int *const a;   //都不变，即（*a）不变，a也不变
```

#### 1.1.21 说说使用指针需要注意什么？

**参考回答**

1. 定义指针时，先初始化为NULL。
2. 用malloc或new申请内存之后，应该**立即检查**指针值是否为NULL。防止使用指针值为NULL的内存。
3. 不要忘记为数组和动态内存**赋初值**。防止将未被初始化的内存作为右值使用。
4. 避免数字或指针的下标**越界**，特别要当心发生“多1”或者“少1”操作
5. 动态内存的申请与释放必须配对，防止**内存泄漏**
6. 用free或delete释放了内存之后，立即将指针**设置为NULL**，防止“野指针”

**答案解析**

（1）初始化置NULL

（2）申请内存后判空

（3）指针释放后置NULL

```C++
int *p = NULL; //初始化置NULL
p = (int *)malloc(sizeof(int)*n); //申请n个int内存空间  
assert(p != NULL); //判空，防错设计
p = (int *) realloc(p, 25);//重新分配内存, p 所指向的内存块会被释放并分配一个新的内存地址
free(p);  
p = NULL; //释放后置空

int *p1 = NULL; //初始化置NULL
p1 = (int *)calloc(n, sizeof(int)); //申请n个int内存空间同时初始化为0 
assert(p1 != NULL); //判空，防错设计
free(p1);  
p1 = NULL; //释放后置空

int *p2 = NULL; //初始化置NULL
p2 = new int[n]; //申请n个int内存空间  
assert(p2 != NULL); //判空，防错设计
delete []p2;  
p2 = nullptr; //释放后置空  
```

#### 1.1.22 说说内联函数和函数的区别，内联函数的作用。

**参考回答**

1. 内联函数比普通函数多了关键字**inline**
2. 内联函数避免了函数调用的**开销**；普通函数有调用的开销
3. 普通函数在被调用的时候，需要**寻址（函数入口地址）**；内联函数不需要寻址。
4. 内联函数有一定的限制，内联函数体要求**代码简单**，不能包含复杂的结构控制语句；普通函数没有这个要求。

**内联函数的作用**：内联函数在调用时，是将调用表达式用内联函数体来替换。避免函数调用的开销。

**答案解析**

在使用内联函数时，应注意如下几点：

1. 在内联函数内不允许用循环语句和开关语句。 如果内联函数有这些语句，则编译将该函数视同普通函数那样产生函数调用代码,递归函数是不能被用来做内联函数的。内联函数只适合于只有1～5行的小函数。对一个含有许多语句的大函数，函数调用和返回的开销相对来说微不足道，所以也没有必要用内联函数实现。
2. 内联函数的定义必须出现在内联函数第一次被调用之前。

#### 1.1.23 简述C++有几种传值方式，之间的区别是什么？

**参考回答**

传参方式有这三种：**值传递、引用传递、指针传递**

1. 值传递：形参即使在函数体内值发生变化，也不会影响实参的值；
2. 引用传递：形参在函数体内值发生变化，会影响实参的值；
3. 指针传递：在指针指向没有发生改变的前提下，形参在函数体内值发生变化，会影响实参的值；

**答案解析**

值传递用于对象时，整个对象会拷贝一个副本，这样效率低；而引用传递用于对象时，不发生拷贝行为，只是绑定对象，更高效；指针传递同理，但不如引用传递安全。

代码示例 

```C++
//代码示例
#include <iostream>
using namespace std;

void testfunc(int a, int *b, int &c){//形参a值发生了改变，但是没有影响实参i的值；但形参*b、c的值发生了改变，影响到了实参*j、k的值
    a += 1;
    (*b) += 1;
    c += 1;
    printf("a= %d, b= %d, c= %d\n",a,*b,c);//a= 2, b= 2, c= 2
}
int main(){
       int i = 1;
    int a = 1;
    int *j = &a;
    int k = 1;
    testfunc(i, j, k);
    printf("i= %d, j= %d, k= %d\n",i,*j,k);//i= 1, j= 2, k= 2
    return 0;
}
```

#### 1.1.24 简述const（星号）和（星号）const的区别

**参考回答**

```C++
//const* 是常量指针，*const 是指针常量
int const *a;    //a指针所指向的内存里的值不变，即（*a）不变
int *const a;    //a指针所指向的内存地址不变，即a不变
```





#### 1.1.24 简述const（星号）和（星号）const的区别

```c++
//const* 是常量指针，*const 是指针常量
int const *a;    //a指针所指向的内存里的值不变，即（*a）不变
int *const a;    //a指针所指向的内存地址不变，即a不变
```



### 1.2 C++内存

#### 1.2.1 简述一下堆和栈的区别

**参考回答**

区别：

1. **堆栈空间分配不同**。栈由操作系统自动分配释放 ，存放函数的参数值，局部变量的值等；堆一般由程序员分配释放。
2. **堆栈缓存方式不同**。栈使用的是一级缓存， 它们通常都是被调用时处于存储空间中，调用完毕立即释放；堆则是存放在二级缓存中，速度要慢些。
3. **堆栈数据结构不同**。堆类似数组结构；栈类似栈结构，先进后出。

#### 1.2.2 简述C++的内存管理

**参考回答**

1. **内存分配方式**：

    在C++中，内存分成5个区，他们分别是堆、栈、自由存储区、全局/静态存储区和常量存储区。

    **栈**，在执行函数时，函数内局部变量的存储单元都可以在栈上创建，函数执行结束时这些存储单元自动被释放。

    **堆**，就是那些由new分配的内存块，一般一个new就要对应一个delete。

    **自由存储区**，就是那些由malloc等分配的内存块，和堆是十分相似的，不过是用free来结束自己的生命。

    **全局/静态存储区**，全局变量和静态变量被分配到同一块内存中

    **常量存储区**，这是一块比较特殊的存储区，里面存放的是常量，不允许修改。

2. **常见的内存错误及其对策**：

    （1）内存分配未成功，却使用了它。

    （2）内存分配虽然成功，但是尚未初始化就引用它。

    （3）内存分配成功并且已经初始化，但操作越过了内存的边界。

    （4）忘记了释放内存，造成内存泄露。

    （5）释放了内存却继续使用它。

    对策：

    （1）定义指针时，先初始化为NULL。

    （2）用malloc或new申请内存之后，应该**立即检查**指针值是否为NULL。防止使用指针值为NULL的内存。

    （3）不要忘记为数组和动态内存**赋初值**。防止将未被初始化的内存作为右值使用。

    （4）避免数字或指针的下标**越界**，特别要当心发生“多1”或者“少1”操作

    （5）动态内存的申请与释放必须配对，防止**内存泄漏**

    （6）用free或delete释放了内存之后，立即将指针**设置为NULL**，防止“野指针”

    （7）使用智能指针。

3. **内存泄露及解决办法**：

    **什么是内存泄露？**

    简单地说就是申请了一块内存空间，使用完毕后没有释放掉。（1）new和malloc申请资源使用后，没有用delete和free释放；（2）子类继承父类时，父类析构函数不是虚函数。（3）Windows句柄资源使用后没有释放。

    **怎么检测？**

    第一：良好的编码习惯，使用了内存分配的函数，一旦使用完毕,要记得使用其相应的函数释放掉。

    第二：将分配的内存的指针以链表的形式自行管理，使用完毕之后从链表中删除，程序结束时可检查改链表。

    第三：使用智能指针。

    第四：一些常见的工具插件，如ccmalloc、Dmalloc、Leaky、Valgrind等等。

#### 1.2.3 malloc和局部变量分配在堆还是栈？

**参考回答**

​    malloc是在**堆上分配内存**，需要程序员自己回收内存；局部变量是在**栈中分配内存**，超过作用域就自动回收。

#### 1.2.4 程序有哪些section，分别的作用？程序启动的过程？怎么判断数据分配在栈上还是堆上？

**参考回答**

![img](https://uploadfiles.nowcoder.com/images/20220225/4107856_1645788015668/798C7A2D023204559B62F88B54E35CBB)

**一个程序有哪些section：**

如上图，**从低地址到高地址，一个程序由代码段、数据段、BSS段、堆、共享区、栈等**组成。

1. **数据段：**存放程序中已初始化的全局变量和静态变量的一块内存区域。

2. **代码段：**存放程序执行代码的一块内存区域。只读，代码段的头部还会包含一些只读的常数变量。

3. **BSS** 段：存放程序中未初始化的全局变量和静态变量的一块内存区域。

4. 可执行程序在运行时又会多出两个区域：堆区和栈区。

    **堆区：**动态申请内存用。堆从低地址向高地址增长。

    **栈区：**存储局部变量、函数参数值。栈从高地址向低地址增长。是一块连续的空间。

5. 最后还有一个**共享区**，位于堆和栈之间。

**程序启动的过程：**

1. 操作系统首先创建相应的进程并分配私有的进程空间，然后操作系统的加载器负责把可执行文件的数据段和代码段映射到进程的虚拟内存空间中。
2. 加载器读入可执行程序的导入符号表，根据这些符号表可以查找出该可执行程序的所有依赖的动态链接库。
3. 加载器针对该程序的每一个动态链接库调用LoadLibrary （1）查找对应的动态库文件，加载器为该动态链接库确定一个合适的基地址。 （2）加载器读取该动态链接库的导入符号表和导出符号表，比较应用程序要求的导入符号是否匹配该库的导出符号。 （3）针对该库的导入符号表，查找对应的依赖的动态链接库，如有跳转，则跳到3 （4）调用该动态链接库的初始化函数
4. 初始化应用程序的全局变量，对于全局对象自动调用构造函数。
5. 进入应用程序入口点函数开始执行。

**怎么判断数据分配在栈上还是堆上：**首先局部变量分配在栈上；而通过malloc和new申请的空间是在堆上。

#### 1.2.5 初始化为0的全局变量在bss还是data

**参考回答**

BSS段通常是指用来存放程序中未初始化的或者初始化为0的全局变量和静态变量的一块内存区域。特点是可读写的，在程序执行之前BSS段会自动清0。

#### 1.2.6 什么是内存泄露，内存泄露怎么检测？

**参考回答**

**什么是内存泄露？**

简单地说就是申请了一块内存空间，使用完毕后没有释放掉。（1）new和malloc申请资源使用后，没有用delete和free释放；（2）子类继承父类时，父类析构函数不是虚函数。（3）Windows句柄资源使用后没有释放。

**怎么检测？**

第一：良好的编码习惯，使用了内存分配的函数，一旦使用完毕,要记得使用其相应的函数释放掉。

第二：将分配的内存的指针以链表的形式自行管理，使用完毕之后从链表中删除，程序结束时可检查改链表。

第三：使用智能指针。

第四：一些常见的工具插件，如ccmalloc、Dmalloc、Leaky、Valgrind等等。

#### 1.2.7 请简述一下atomoic内存顺序。

**参考回答**

有六个内存顺序选项可应用于对原子类型的操作：

1. memory_order_relaxed：在原子类型上的操作以自由序列执行，没有任何同步关系，仅对此操作要求原子性。
2. memory_order_consume：memory_order_consume只会对其标识的对象保证该对象存储先行于那些需要加载该对象的操作。
3. memory_order_acquire：使用memory_order_acquire的原子操作，当前线程的读写操作都不能重排到此操作之前。
4. memory_order_release：使用memory_order_release的原子操作，当前线程的读写操作都不能重排到此操作之后。
5. memory_order_acq_rel：memory_order_acq_rel在此内存顺序的读-改-写操作既是获得加载又是释放操作。没有操作能够从此操作之后被重排到此操作之前，也没有操作能够从此操作之前被重排到此操作之后。
6. memory_order_seq_cst：memory_order_seq_cst比std::memory_order_acq_rel更为严格。memory_order_seq_cst不仅是一个"获取释放"内存顺序，它还会对所有拥有此标签的内存操作建立一个单独全序。

除非你为特定的操作指定一个顺序选项，否则内存顺序选项对于所有原子类型默认都是memory_order_seq_cst。

#### 1.2.8 内存模型，堆栈，常量区。

**参考回答**

![img](https://uploadfiles.nowcoder.com/images/20220225/4107856_1645788035619/FC055373B87370BDAA91631459B38E30)

**内存模型（内存布局）：**

如上图，**从低地址到高地址，一个程序由代码段、数据段、BSS段、堆、共享区、栈等**组成。

1. **数据段：**存放程序中已初始化的全局变量和静态变量的一块内存区域。

2. **代码段：**存放程序执行代码的一块内存区域。只读，代码段的头部还会包含一些只读的常数变量。

3. **BSS** 段：存放程序中未初始化的全局变量和静态变量的一块内存区域。

4. 可执行程序在运行时又会多出两个区域：堆区和栈区。

    **堆区：**动态申请内存用。堆从低地址向高地址增长。

    **栈区：**存储局部变量、函数参数值。栈从高地址向低地址增长。是一块连续的空间。

5. 最后还有一个**共享区**，位于堆和栈之间。

**堆 heap** ：由new分配的内存块，其释放由程序员控制（一个new对应一个delete）

**栈 stack** ：是那些编译器在需要时分配，在不需要时自动清除的存储区。存放局部变量、函数参数。

**常量存储区** ：存放常量，不允许修改。

#### 1.2.9 简述C++中内存对齐的使用场景

**参考回答**

内存对齐应用于三种数据类型中：**struct/class/union**

struct/class/union内存对齐原则有四个：

1. 数据成员对齐规则：结构(struct)或联合(union)的数据成员，第一个数据成员放在offset为0的地方，以后每个数据成员存储的起始位置要从该成员大小或者成员的子成员大小的整数倍开始。
2. 结构体作为成员:如果一个结构里有某些结构体成员,则结构体成员要从其内部"最宽基本类型成员"的整数倍地址开始存储。(struct a里存有struct b,b里有char,int ,double等元素,那b应该从8的整数倍开始存储)。
3. 收尾工作:结构体的总大小，也就是sizeof的结果，必须是其内部最大成员的"最宽基本类型成员"的整数倍。不足的要补齐。(基本类型不包括struct/class/uinon)。
4. sizeof(union)，以结构里面size最大元素为union的size，因为在某一时刻，union只有一个成员真正存储于该地址。

**答案解析**

1. **什么是内存对齐？**

    那么什么是字节对齐？在C语言中，结构体是一种复合数据类型，其构成元素既可以是基本数据类型（如int、long、float等）的变量，也可以是一些复合数据类型（如数组、结构体、联合体等）的数据单元。在结构体中，**编译器为结构体的每个成员按其自然边界（alignment）分配空间。**各个成员按照它们被声明的顺序在内存中顺序存储，第一个成员的地址和整个结构体的地址相同。

    为了使CPU能够对变量进行快速的访问，变量的起始地址应该具有某些特性，**即所谓的“对齐”，比如4字节的int型，其起始地址应该位于4字节的边界上，即起始地址能够被4整除**，也即“对齐”跟数据在内存中的位置有关。如果一个变量的内存地址正好位于它长度的整数倍，他就被称做自然对齐。

    比如在32位cpu下，假设一个整型变量的地址为0x00000004(为4的倍数)，那它就是自然对齐的，而如果其地址为0x00000002（非4的倍数）则是非对齐的。现代计算机中内存空间都是按照byte划分的，从理论上讲似乎对任何类型的变量的访问可以从任何地址开始，但实际情况是在访问特定类型变量的时候经常在特定的内存地址访问，这就需要各种类型数据按照一定的规则在空间上排列，而不是顺序的一个接一个的排放，这就是对齐。

2. **为什么要字节对齐？**

    需要字节对齐的根本原因在于CPU访问数据的效率问题。假设上面整型变量的地址不是自然对齐，比如为0x00000002，则CPU如果取它的值的话需要访问两次内存，第一次取从0x00000002-0x00000003的一个short，第二次取从0x00000004-0x00000005的一个short然后组合得到所要的数据，如果变量在0x00000003地址上的话则要访问三次内存，第一次为char，第二次为short，第三次为char，然后组合得到整型数据。

    而如果变量在自然对齐位置上，则只要一次就可以取出数据。一些系统对对齐要求非常严格，比如sparc系统，如果取未对齐的数据会发生错误，而在x86上就不会出现错误，只是效率下降。

    各个硬件平台对存储空间的处理上有很大的不同。一些平台对某些特定类型的数据只能从某些特定地址开始存取。比如有些平台每次读都是从偶地址开始，如果一个int型（假设为32位系统）如果存放在偶地址开始的地方，那么一个读周期就可以读出这32bit，而如果存放在奇地址开始的地方，就需要2个读周期，并对两次读出的结果的高低字节进行拼凑才能得到该32bit数据。显然在读取效率上下降很多。

3. **字节对齐实例**

    ```C++
    union example {    int a[5];    char b;    double c;   };   
    int result = sizeof(example);   
    /* 	如果以最长20字节为准，内部double占8字节，这段内存的地址0x00000020并不是double的整数倍，
    	只有当最小为0x00000024时可以满足整除double（8Byte）
    	同时又可以容纳int a[5]的大小，所以正确的结果应该是result=24 */  
    
    struct example {    int a[5];    char b;    double c;   } 
    test_struct; int result = sizeof(test_struct);   
    /* 	如果我们不考虑字节对齐，那么内存地址0x0021不是double（8Byte）的整数倍，所以需要字节对齐，
    	那么此时满足是double（8Byte）的整数倍的最小整数是0x0024，说明此时char b对齐int扩充了三个字节。
    	所以最后的结果是result=32 */  
    
    struct example {    char b;    double c;    int a;   }test_struct;   
    int result = sizeof(test_struct);   
    /* 	字节对齐除了内存起始地址要是数据类型的整数倍以外，还要满足一个条件，
    	那就是占用的内存空间大小需要是结构体中占用最大内存空间的类型的整数倍，
    	所以20不是double（8Byte）的整数倍，我们还要扩充四个字节，
    	最后的结果是result=24 */
    ```





### 1.3 面向对象

#### 1.3.1 简述一下什么是面向对象

**参考回答**

1. 面向对象是一种编程思想，把一切东西看成是一个个对象，比如人、耳机、鼠标、水杯等，他们各自都有属性，比如：耳机是白色的，鼠标是黑色的，水杯是圆柱形的等等，把这些对象拥有的属性变量和操作这些属性变量的函数打包成一个类来表示

2. 面向过程和面向对象的区别

    面向过程：根据业务逻辑从上到下写代码

    面向对象：将数据与函数绑定到一起，进行封装，这样能够更快速的开发程序，减少了重复代码的重写过程



#### 1.3.2 简述一下面向对象的三大特征

**参考回答**

面向对象的三大特征是封装、继承、多态。

1. 封装：将数据和操作数据的方法进行有机结合，***隐藏对象的属性和实现细节，仅对外公开接口来和对象进行 交互***。封装本质上是一种管理：我们如何管理兵马俑呢？比如如果什么都不管，兵马俑就被随意破坏了。那么我们首先建了一座房子把兵马俑给封装起来。但是我们目的全封装起来，不让别人看。所以我们开放了售票通 道，可以买票突破封装在合理的监管机制下进去参观。类也是一样，不想给别人看到的，我们使用protected/private把成员封装起来。开放一些共有的成员函数对成员合理的访问。所以封装本质是一种管理。

2. 继承：**可以使用现有类的所有功能**，**并在无需重新编写原来的类的情况下对这些功能进行扩展**。

    三种继承方式

    | 继承方式            | private继承     | protected继承     | public继承                   |
    | ------------------- | --------------- | ----------------- | ---------------------------- |
    | 基类的private成员   | 不可见          | 不可见            | 不可见                       |
    | 基类的protected成员 | 变为private成员 | 仍为protected成员 | 仍为protected成员            |
    | 基类的public成员    | 变为private成员 | 变为protected成员 | 仍为public成员仍为public成员 |

3. 多态：**用父类型别的指针指向其子类的实例**，然后**通过父类的指针调用实际子类的成员函数**。实现多态，有二种方式，**重写**，**重载**。

#### 1.3.3 简述一下 C++ 的重载和重写，以及它们的区别

**标准回答：**

* 重载：同一作用域，同名函数，参数的顺序、个数、类型不同 都可以重载。函数的返回值 类型不能作为重载条件（函数重载、运算符重载） 
* 重定义：有继承，子类 重定义 父类的同名函数（非虚函数）， 参数顺序、个数、类型可以不同。子类的同名函数会屏蔽父类的所有同名函数（可以通过作用域解决） 
* 重写（覆盖）：有继承，子类 重写 父类的虚函数。返回值类型、函数名、参数顺序、个数、类型都必须一致。



**参考答案**

1. 重写

    是指派生类中存在重新定义的函数。其函数名，参数列表，返回值类型，所有都必须同基类中被重写的函数一致。只有函数体不同（花括号内），**派生类对象调用时会调用派生类的重写函数，不会调用被重写函数。重写的基类中被重写的函数必须有virtual修饰**。

    示例如下：

```C++
#include<bits/stdc++.h>  
using namespace std;  
class A { 
public:  
    virtual void fun()  {   cout << "A";  } 
}; 

class B :public A 
{ 
public:  
    virtual void fun()  {   cout << "B";  } 
}; 

int main(void) 
{  
    A* a = new B();  
    a->fun();//输出B，A类中的fun在B类中重写 
}
```

1. 重载

    我们在平时写代码中会用到几个函数但是他们的实现功能相同，但是有些细节却不同。例如：交换两个数的值其中包括（int, float,char,double)这些个类型。在C语言中我们是利用不同的函数名来加以区分。这样的代码不美观而且给程序猿也带来了很多的不便。于是在C++中人们提出了用一个函数名定义多个函数，也就是所谓的函数重载。函数重载是指同一可访问区内被声明的几个具有不同参数列（参数的类型，个数，顺序不同）的同名函数，根据参数列表确定调用哪个函数，重载不关心函数返回类型。

```c++
#include<bits/stdc++.h>  using namespace std;  class A {  void fun() {};  void fun(int i) {};  void fun(int i, int j) {};     void fun1(int i,int j){}; };
```

#### 1.3.4 说说 C++ 的重载和重写是如何实现的

**参考答案**

1. C++利用命名倾轧（name mangling）技术，来改名函数名，区分参数不同的同名函数。命名倾轧是在**编译阶段**完成的。

    C++定义同名重载函数：

    ```c++
    #include<iostream> 
    using namespace std; 
    int func(int a,double b) {  return ((a)+(b)); } 
    int func(double a,float b) {  return ((a)+(b)); } 
    int func(float a,int b) {  return ((a)+(b)); } 
    int main() {  return 0; }
    ```

    ![img](https://uploadfiles.nowcoder.com/images/20220225/4107856_1645788124958/5E57B0F4AE72F40057C2EAA16C4DB902)

    由上图可得，d代表double，f代表float，i代表int，加上参数首字母以区分同名函数。

2. 在基类的函数前加上virtual关键字，在派生类中重写该函数，运行时将会根据对象的实际类型来调用相应的函数。如果对象类型是派生类，就调用派生类的函数；如果对象类型是基类，就调用基类的函数。

    1. 用virtual关键字申明的函数叫做虚函数，虚函数肯定是类的成员函数。
    2. 存在虚函数的类都有一个一维的虚函数表叫做虚表，类的对象有一个指向虚表开始的虚指针。虚表是和类对应的，虚表指针是和对象对应的。
    3. 多态性是一个接口多种实现，是面向对象的核心，分为类的多态性和函数的多态性。
    4. 重写用虚函数来实现，结合动态绑定。
    5. 纯虚函数是虚函数再加上 = 0。
    6. 抽象类是指包括至少一个纯虚函数的类。

    纯虚函数：virtual void fun()=0。即抽象类必须在子类实现这个函数，即先有名称，没有内容，在派生类实现内容。
    
3. 谈谈动态捆绑的机制

* 虚函数的实现原理是 : 当一个父类的成员函数被 virtual 修饰的时候 , 如果还没有涉及到继承 ,  就会产生一个虚函数指针 , 
* 这个虚函数指针 指向 一张虚函数表 , 表里面记录的是 父函数的入口地址 , 
* 一旦这个类派生出子类 , 同样会继承 父类的虚函数指针 , 且指向虚函数表 , 表里面记录的也是 父函数的入口地址 , 
* 但是当子类一旦重写 父类的虚函数 , 这个时候虚函数表的入口地址 , 就会被覆盖成子类重写的 虚函数函数入口地址 , 
* 这时 , 当我们用父类的指针去调用虚函数的时候 , 就会间接的调用子类的虚函数

所以这里如果没有 子类继承父类的析构函数 但是这个析构函数不是虚析构函数 那么就**可能会发生内存泄漏** 因为默认虚函数指针vptr指向的是父类的虚函数表 默认调用父类的函数



#### 1.3.5 说说 C 语言如何实现 C++ 语言中的重载

**参考答案**

c语言中不允许有同名函数，因为编译时函数命名是一样的，不像c++会添加参数类型和返回类型作为函数编译后的名称，进而实现重载。如果要用c语言显现函数重载，可通过以下方式来实现：

1. 使用函数指针来实现，重载的函数不能使用同名称，只是类似的实现了函数重载功能
2. 重载函数使用可变参数，方式如打开文件open函数
3. gcc有内置函数，程序使用编译函数可以实现函数重载

示例如下：

```C++
#include<stdio.h>   
void func_int(void * a) 
{     
    printf("%d\n",*(int*)a);  //输出int类型，注意 void * 转化为int 
}   

void func_double(void * b) 
{     
    printf("%.2f\n",*(double*)b); 
}   

typedef void (*ptr)(void *);  //typedef申明一个函数指针   
void c_func(ptr p,void *param) 
{      
    p(param);                //调用对应函数 
}   

int main() 
{     
    int a = 23;     
    double b = 23.23;     
    c_func(func_int,&a);     
    c_func(func_double,&b);     
    return 0; 
}
```

#### 1.3.6 说说构造函数有几种，分别什么作用

**参考答案**

C++中的构造函数可以分为4类：默认构造函数、初始化构造函数、拷贝构造函数、移动构造函数。

1. 默认构造函数和初始化构造函数。 在定义类的对象的时候，完成对象的初始化工作。

    ```C++
    class Student 
    { 
    public:  
        //默认构造函数  
        Student()  {     num=1001;        age=18;      }  
        //初始化构造函数  
        Student(int n,int a):num(n),age(a){} 
    private:  
        int num;  
        int age; 
    }; 
    
    int main() {  
        //用默认构造函数初始化对象
        S1  Student s1;  
        //用初始化构造函数初始化对象
        S2  Student s2(1002,18);  
        return 0; 
    }
    ```

    **有了有参的构造了，编译器就不提供默认的构造函数。**

    

2. 拷贝构造函数

    ```C++
    #include "stdafx.h" 
    #include "iostream.h"  
    class Test {     
        int i;     
        int *p; 
    public:     
        Test(int ai,int value)     
        {         
            i = ai;         
            p = new int(value);     
        }    
        ~Test()     
        {
            delete p;     
        }     
        Test(const Test& t)     
        {         
            this->i = t.i;
            this->p = new int(*t.p);
        } 
    }; 
    //复制构造函数用于复制本类的对象 
    int main(int argc, char* argv[]) 
    {     
        Test t1(1,2);     
        Test t2(t1);//将对象t1复制给t2。注意复制和赋值的概念不同     
        return 0; 
    }
    ```

    赋值构造函数默认实现的是值拷贝（浅拷贝）。

    

3. 移动构造函数。用于将其他类型的变量，隐式转换为本类对象。下面的转换构造函数，将int类型的r转换为Student类型的对象，对象的age为r，num为1004.

    ```c++
    #include<iostream>  
    using namespace std;  
    class IntNum{  
    public:  
         IntNum(int x = 0):xptr(new int(x)){//构造函数  
           cout<<"Calling constructor..."<<endl;  
    }  
        IntNum(const IntNum &n):xptr(new int(*n.xpr)){//复制构造函数  
             cout<<"Calling copy constructor..."<<endl;  
    } 
       IntNum(IntNum && n):xptr(n.xptr){//移动构造函数
         n.xptr = nullptr;
         cout<<"Calling move constructor..."<<endl;
    }
           ~IntNum(){//析构函数  
            delete xpr;  
            cout<<"Destructing..."<<endl;
    } 
            int getInt(){return *ptr;}//返回指针所指向的值，而不是返回指针本身  
    private:  
             int *ptr;  
    };  
      
    //返回值为IntNum类对象  
    IntNum getNum(){  
         //定义了一个局部对象，然后将局部对象作为结果返回  
          IntNum a;  
        //返回值是IntNum类型  
          return a;  
    }  
      int main(){  
       //getNum()函数返回了一个IntNum类型的对象（临时无名对象），之后调用类的函数  
        cout<<"getNum().getInt()"<<endl;  
        return 0;  
    }  
    ```

#### 1.3.7 只定义析构函数，会自动生成哪些构造函数

**参考答案**

只定义了析构函数，编译器将自动为我们生成拷贝构造函数和默认构造函数。

默认构造函数和初始化构造函数。 在定义类的对象的时候，完成对象的初始化工作。

```c++
class Student 
{ 
public:  //默认构造函数  
    Student()  {     num=1001;        age=18;      }  //初始化构造函数  
    Student(int n,int a):num(n),age(a){} 
private:  
    int num;  
    int age; 
}; 

int main() 
{  
    //用默认构造函数初始化对象S1  
    Student s1;  
    //用初始化构造函数初始化对象S2  
    Student s2(1002,18);  
    return 0; 
}
```

有了有参的构造了，编译器就不提供默认的构造函数。

拷贝构造函数

```c++
#include "stdafx.h"
#include "iostream.h"

class Test
{
    int i;
    int *p;
public:
    Test(int ai,int value)
    {
        i = ai;
        p = new int(value);
    }
    ~Test()
    {
        delete p;
    }
    Test(const Test& t)
    {
        this->i = t.i;
        this->p = new int(*t.p);
    }
};

int main(int argc, char* argv[])
{
    Test t1(1,2);
    Test t2(t1);//将对象t1复制给t2。注意复制和赋值的概念不同。
    
    return 0;
}
```

赋值构造函数默认实现的是值拷贝（浅拷贝）。

**答案解析**

示例如下：

```c++
class HasPtr
{
public:
    HasPtr(const string& s = string()) :ps(new string(s)), i(0) {}
    ~HasPtr() { delete ps; }
private:
    string * ps;
    int i;
};
```

如果类外面有这样一个函数：

```c++
HasPtr f(HasPtr hp)
{
    HasPtr ret = hp;
    ///... 其他操作
    return ret;
 
}
```

当函数执行完了之后，将会调用hp和ret的析构函数，将hp和ret的成员ps给delete掉，但是由于ret和hp指向了同一个对象，因此该对象的ps成员被delete了两次，这样产生一个未定义的错误，所以说，如果一个类定义了析构函数，那么它要定义自己的拷贝构造函数和默认构造函数。

#### 1.3.8 说说一个类，默认会生成哪些函数

**参考答案**

定义一个空类

```
class Empty
{
};
```

默认会生成以下几个函数

1. 无参的构造函数

    在定义类的对象的时候，完成对象的初始化工作。

```
Empty()
{
}
```

1. 拷贝构造函数

    拷贝构造函数用于复制本类的对象

```
Empty(const Empty& copy)
{
}
```

1. 赋值运算符

```
Empty& operator = (const Empty& copy)
{
}
```

1. 析构函数（非虚）

```
~Empty()
{
}
```

#### 1.3.9 说说 C++ 类对象的初始化顺序，有多重继承情况下的顺序

**参考答案**

1. 创建派生类的对象，基类的构造函数优先被调用（也优先于派生类里的成员类）；

2. 如果类里面有成员类，成员类的构造函数优先被调用；(也优先于该类本身的构造函数）

3. 基类构造函数如果有多个基类，则构造函数的调用顺序是某类在类派生表中出现的顺序而不是它们在成员初始化表中的顺序；

4. 成员类对象构造函数如果有多个成员类对象，则构造函数的调用顺序是对象在类中被声明的顺序而不是它们出现在成员初始化表中的顺序；

5. 派生类构造函数，作为一般规则派生类构造函数应该不能直接向一个基类数据成员赋值而是把值传递给适当的基类构造函数,否则两个类的实现变成紧耦合的（tightly coupled）将更加难于正确地修改或扩展基类的实现。（基类设计者的责任是提供一组适当的基类构造函数）

6. 综上可以得出，初始化顺序：

    **父类构造函数–>成员类对象构造函数–>自身构造函数**

    其中成员变量的初始化与声明顺序有关，**构造函数的调用顺序是类派生列表中的顺序。**

    **析构顺序和构造顺序相反。**

#### 1.3.10 简述下向上转型和向下转型

1. 子类转换为父类：向上转型，使用dynamic_cast<type_id>(expression)，这种转换相对来说比较安全不会有数据的丢失；
2. 父类转换为子类：向下转型，可以使用强制转换，这种转换时不安全的，会导致数据的丢失，原因是父类的指针或者引用的内存中可能不包含子类的成员的内存。

#### 1.3.11 简述下深拷贝和浅拷贝，如何实现深拷贝

1. 浅拷贝：又称值拷贝，将源对象的值拷贝到目标对象中去，本质上来说源对象和目标对象共用一份实体，只是所引用的变量名不同，地址其实还是相同的。举个简单的例子，你的小名叫西西，大名叫冬冬，当别人叫你西西或者冬冬的时候你都会答应，这两个名字虽然不相同，但是都指的是你。

2. 深拷贝，拷贝的时候先开辟出和源对象大小一样的空间，然后将源对象里的内容拷贝到目标对象中去，这样两个指针就指向了不同的内存位置。并且里面的内容是一样的，这样不但达到了我们想要的目的，还不会出现问题，两个指针先后去调用析构函数，分别释放自己所指向的位置。即为每次增加一个指针，便申请一块新的内存，并让这个指针指向新的内存，深拷贝情况下，不会出现重复释放同一块内存的错误。

3. 深拷贝的实现：深拷贝的拷贝构造函数和赋值运算符的重载传统实现：

    ```C++
    STRING( const STRING& s )
    {
        //_str = s._str;
        _str = new char[strlen(s._str) + 1];
        strcpy_s( _str, strlen(s._str) + 1, s._str );
    }
    STRING& operator=(const STRING& s)
    {
        if (this != &s)
        {
            //this->_str = s._str;
            delete[] _str;
            this->_str = new char[strlen(s._str) + 1];
            strcpy_s(this->_str, strlen(s._str) + 1, s._str);
        }
        return *this;
    }
    ```

    这里的拷贝构造函数我们很容易理解，先开辟出和源对象一样大的内存区域，然后将需要拷贝的数据复制到目标拷贝对象 ， 那么这里的赋值运算符的重载是怎么样做的呢？

    ![img](https://uploadfiles.nowcoder.com/images/20220225/4107856_1645788163127/9F844C99D8A154A32CA23995A7C1661B)

    这种方法解决了我们的指针悬挂问题，通过不断的开空间让不同的指针指向不同的内存，以防止同一块内存被释放两次的问题。

#### 1.3.12 简述一下 C++ 中的多态

派生类重写基类方法，然后用基类引用指向派生类对象，调用方法时候会进行动态绑定，这就是多态。 多态分为静态多态和动态多态：

1. 静态多态：编译器在编译期间完成的，编译器会根据实参类型来推断该调用哪个函数，如果有对应的函数，就调用，没有则在编译时报错。

    比如一个简单的加法函数：

    ```C++
    include<iostream>
    using namespace std;
    
    int Add(int a,int b)//1
    {
        return a+b;
    }
    
    char Add(char a,char b)//2
    {
        return a+b;
    }
    
    int main()
    {
        cout<<Add(666,888)<<endl;//1
        cout<<Add('1','2');//2
        return 0;
    }
    ```

    显然，第一条语句会调用函数1，而第二条语句会调用函数2，这绝不是因为函数的声明顺序，不信你可以将顺序调过来试试。

2. 动态多态：其实要实现动态多态，需要几个条件——即动态绑定条件：

    1. 虚函数。基类中必须有虚函数，在派生类中必须重写虚函数。
    2. 通过基类类型的指针或引用来调用虚函数。

    说到这，得插播一条概念：重写——也就是基类中有一个虚函数，而在派生类中也要重写一个原型（返回值、名字、参数）都相同的虚函数。不过协变例外。协变是重写的特例，基类中返回值是基类类型的引用或指针，在派生类中，返回值为派生类类型的引用或指针。

    ```C++
    //协变测试函数
    #include<iostream>
    using namespace std;
    
    class Base
    {
    public:
        virtual Base* FunTest()
        {
            cout << "victory" << endl;
            return this;
        }
    };
    
    class Derived :public Base
    {
    public:
        virtual Derived* FunTest()
        {
            cout << "yeah" << endl;
            return this;
        }
    };
    
    int main()
    {
        Base b;
        Derived d;
    
        b.FunTest();
        d.FunTest();
    
        return 0;
    }
    ```

#### 1.3.13 说说为什么要虚析构，为什么不能虚构造

1. 虚析构：将可能会被继承的父类的析构函数设置为虚函数，可以保证当我们new一个子类，然后使用基类指针指向该子类对象，**释放基类指针时可以释放掉子类的空间，防止内存泄漏**。如果基类的析构函数不是虚函数，在特定情况下会导致派生来无法被析构。

    1. 用派生类类型指针绑定派生类实例，析构的时候，不管基类析构函数是不是虚函数，都会正常析构
    2. 用基类类型指针绑定派生类实例，析构的时候，如果基类析构函数不是虚函数，则只会析构基类，不会析构派生类对象，从而造成内存泄漏。为什么会出现这种现象呢，个人认为析构的时候如果没有虚函数的动态绑定功能，就只根据指针的类型来进行的，而不是根据指针绑定的对象来进行，所以只是调用了基类的析构函数；如果基类的析构函数是虚函数，则析构的时候就要根据指针绑定的对象来调用对应的析构函数了。

    C++默认的析构函数不是虚函数是因为虚函数需要额外的虚函数表和虚表指针，占用额外的内存。而对于不会被继承的类来说，其析构函数如果是虚函数，就会浪费内存。因此C++默认的析构函数不是虚函数，而是只有当需要当作父类时，设置为虚函数。

2. 不能虚构造：

    1. 从存储空间角度：虚函数对应一个vtale,这个表的地址是存储在对象的内存空间的。如果将构造函数设置为虚函数，就需要到vtable 中调用，可是对象还没有实例化，没有内存空间分配，如何调用。（悖论）
    2. 从使用角度：虚函数主要用于在信息不全的情况下，能使重载的函数得到对应的调用。构造函数本身就是要初始化实例，那使用虚函数也没有实际意义呀。所以构造函数没有必要是虚函数。虚函数的作用在于通过父类的指针或者引用来调用它的时候能够变成调用子类的那个成员函数。而构造函数是在创建对象时自动调用的，不可能通过父类的指针或者引用去调用，因此也就规定构造函数不能是虚函数。
    3. 从实现上看，vbtl 在构造函数调用后才建立，因而构造函数不可能成为虚函数。从实际含义上看，在调用构造函数时还不能确定对象的真实类型（因为子类会调父类的构造函数）；而且构造函数的作用是提供初始化，在对象生命期只执行一次，不是对象的动态行为，也没有太大的必要成为虚函数。

#### 1.3.14 说说模板类是在什么时候实现的

1. 模板实例化：模板的实例化分为**显示实例化和隐式实例化**，前者是研发人员明确的告诉模板应该使用什么样的类型去生成具体的类或函数，后者是在编译的过程中由编译器来决定使用什么类型来实例化一个模板不管是显示实例化或隐式实例化，最终生成的类或函数完全是按照模板的定义来实现的

2. 模板具体化：当模板使用某种类型类型实例化后生成的类或函数不能满足需要时，可以考虑对模板进行具体化。具体化时可以修改原模板的定义，当使用该类型时，按照具体化后的定义实现，具体化相当于对某种类型进行特殊处理。

3. 代码示例：

    ```C++
    #include <iostream>
    using namespace std;
    
    // #1 模板定义
    template<class T>
    struct TemplateStruct
    {
        TemplateStruct()
        {
            cout << sizeof(T) << endl;
        }
    };
    
    // #2 模板显示实例化
    template struct TemplateStruct<int>;
    
    // #3 模板具体化
    template<> struct TemplateStruct<double>
    {
        TemplateStruct() {
            cout << "--8--" << endl;
        }
    };
    
    int main()
    {
        TemplateStruct<int> intStruct;
        TemplateStruct<double> doubleStruct;
    
        // #4 模板隐式实例化
        TemplateStruct<char> llStruct;
    }
    ```

    运行结果：

    ```
    4
    --8--
    1
    ```

#### 1.3.15 说说类继承时，派生类对不同关键字修饰的基类方法的访问权限

类中的成员可以分为三种类型，分别为public成员、protected成员、public成员。类中可以直接访问自己类的public、protected、private成员，但类对象只能访问自己类的public成员。

1. public继承：派生类可以访问基类的public、protected成员，不可以访问基类的private成员； 派生类对象可以访问基类的public成员，不可以访问基类的protected、private成员。
2. protected继承：派生类可以访问基类的public、protected成员，不可以访问基类的private成员； 派生类对象不可以访问基类的public、protected、private成员。
3. private继承：派生类可以访问基类的public、protected成员，不可以访问基类的private成员； 派生类对象不可以访问基类的public、protected、private成员。

#### 1.3.16 简述一下移动构造函数，什么库用到了这个函数？

C++11中新增了移动构造函数。与拷贝类似，移动也使用一个对象的值设置另一个对象的值。但是，又与拷贝不同的是，移动实现的是对象值真实的转移（源对象到目的对象）：源对象将丢失其内容，其内容将被目的对象占有。移动操作的发生的时候，是当移动值的对象是未命名的对象的时候。这里未命名的对象就是那些临时变量，甚至都不会有名称。典型的未命名对象就是函数的返回值或者类型转换的对象。使用临时对象的值初始化另一个对象值，不会要求对对象的复制：因为临时对象不会有其它使用，因而，它的值可以被移动到目的对象。做到这些，就要使用移动构造函数和移动赋值：当使用一个临时变量对对象进行构造初始化的时候，调用移动构造函数。类似的，使用未命名的变量的值赋给一个对象时，调用移动赋值操作。

移动操作的概念对对象管理它们使用的存储空间很有用的，诸如对象使用new和delete分配内存的时候。在这类对象中，拷贝和移动是不同的操作：从A拷贝到B意味着，B分配了新内存，A的整个内容被拷贝到为B分配的新内存上。 而从A移动到B意味着分配给A的内存转移给了B，没有分配新的内存，它仅仅包含简单地拷贝指针。 看下面的例子：

```
// 移动构造函数和赋值
#include <iostream>
#include <string>
using namespace std;

class Example6 {
    string* ptr;
public:
    Example6 (const string& str) : ptr(new string(str)) {}
    ~Example6 () {delete ptr;}
    // 移动构造函数，参数x不能是const Pointer&& x，
    // 因为要改变x的成员数据的值；
    // C++98不支持，C++0x（C++11）支持
    Example6 (Example6&& x) : ptr(x.ptr) 
    {
        x.ptr = nullptr;
    }
    // move assignment
    Example6& operator= (Example6&& x) 
    {
        delete ptr; 
        ptr = x.ptr;
        x.ptr=nullptr;
        return *this;
    }
    // access content:
    const string& content() const {return *ptr;}
    // addition:
    Example6 operator+(const Example6& rhs) 
    {
        return Example6(content()+rhs.content());
    }
};
int main () {
    Example6 foo("Exam");           // 构造函数
    // Example6 bar = Example6("ple"); // 拷贝构造函数
    Example6 bar(move(foo));     // 移动构造函数
                                // 调用move之后，foo变为一个右值引用变量，
                                // 此时，foo所指向的字符串已经被"掏空"，
                                // 所以此时不能再调用foo
    bar = bar+ bar;             // 移动赋值，在这儿"="号右边的加法操作，
                                // 产生一个临时值，即一个右值
                                 // 所以此时调用移动赋值语句
    cout << "foo's content: " << foo.content() << '\n';
    return 0;
}
```

执行结果：

```
foo's content: Example
```

#### 1.3.17 请你回答一下 C++ 类内可以定义引用数据成员吗？

c++类内可以定义引用成员变量，但要遵循以下三个规则：

1. 不能用默认构造函数初始化，必须提供构造函数来初始化引用成员变量。否则会造成引用未初始化错误。
2. 构造函数的形参也必须是引用类型。
3. 不能在构造函数里初始化，必须在初始化列表中进行初始化。

#### 1.3.18 构造函数为什么不能被声明为虚函数？

1. 从存储空间角度：虚函数对应一个vtale,这个表的地址是存储在对象的内存空间的。如果将构造函数设置为虚函数，就需要到vtable 中调用，可是对象还没有实例化，没有内存空间分配，如何调用。（悖论）
2. 从使用角度：虚函数主要用于在信息不全的情况下，能使重载的函数得到对应的调用。构造函数本身就是要初始化实例，那使用虚函数也没有实际意义呀。所以构造函数没有必要是虚函数。虚函数的作用在于通过父类的指针或者引用来调用它的时候能够变成调用子类的那个成员函数。而构造函数是在创建对象时自动调用的，不可能通过父类的指针或者引用去调用，因此也就规定构造函数不能是虚函数。
3. 从实现上看，vbtl 在构造函数调用后才建立，因而构造函数不可能成为虚函数。从实际含义上看，在调用构造函数时还不能确定对象的真实类型（因为子类会调父类的构造函数）；而且构造函数的作用是提供初始化，在对象生命期只执行一次，不是对象的动态行为，也没有太大的必要成为虚函数。

#### 1.3.19 简述一下什么是常函数，有什么作用

类的成员函数后面加 const，表明这个函数不会对这个类对象的数据成员（准确地说是非静态数据成员）作任何改变。在设计类的时候，一个原则就是对于不改变数据成员的成员函数都要在后面加const，而对于改变数据成员的成员函数不能加 const。所以 const 关键字对成员函数的行为作了更明确的限定：有 const 修饰的成员函数（指 const 放在函数参数表的后面，而不是在函数前面或者参数表内），只能读取数据成员，不能改变数据成员；没有 const 修饰的成员函数，对数据成员则是可读可写的。除此之外，在类的成员函数后面加 const 还有什么好处呢？那就是常量（即 const）对象可以调用 const 成员函数，而不能调用非const修饰的函数。正如非const类型的数据可以给const类型的变量赋值一样，反之则不成立。

```
#include<iostream>
using namespace std;
 
class CStu
{
public:
    int a;
    CStu()
    {
        a = 12;
    }
 
    void Show() const
    {
        //a = 13; //常函数不能修改数据成员
        cout <<a << "I am show()" << endl;
    }
};
 
int main()
{
    CStu st;
    st.Show();
    system("pause");
    return 0;
}
```

#### 1.3.20 说说什么是虚继承，解决什么问题，如何实现？

虚继承是解决C++多重继承问题的一种手段，从不同途径继承来的同一基类，会在子类中存在多份拷贝。这将存在两个问题：其一，浪费存储空间；第二，存在二义性问题，通常可以将派生类对象的地址赋值给基类对象，实现的具体方式是，将基类指针指向继承类（继承类有基类的拷贝）中的基类对象的地址，但是多重继承可能存在一个基类的多份拷贝，这就出现了二义性。虚继承可以解决多种继承前面提到的两个问题

```
#include<iostream>
using namespace std;
class A{
public:
    int _a;
};
class B :virtual public A
{
public:
    int _b;
};
class C :virtual public A
{
public:
    int _c;
};
class D :public B, public C
{
public:
    int _d;
};
//菱形继承和菱形虚继承的对象模型
int main()
{
    D d;
    d.B::_a = 1;
    d.C::_a = 2;
    d._b = 3;
    d._c = 4;
    d._d = 5;
    cout << sizeof(D) << endl;
    return 0;
}
```

分别从菱形继承和虚继承来分析：

![img](https://uploadfiles.nowcoder.com/images/20220225/4107856_1645788186868/1DBA188A576ED176E295873CC580363A)

菱形继承中A在B,C,D,中各有一份，虚继承中，A共享。

上面的虚继承表实际上是一个指针数组。B、C实际上是虚基表指针，指向虚基表。

虚基表：存放相对偏移量，用来找虚基类

#### 1.3.21 **简述一下虚函数和纯虚函数，以及实现原理**

1. C++中的虚函数的作用主要是实现了多态的机制。关于多态，简而言之就是用父类型的指针指向其子类的实例，然后通过父类的指针调用实际子类的成员函数。这种技术可以让父类的指针有“多种形态”，这是一种泛型技术。如果调用非虚函数，则无论实际对象是什么类型，都执行基类类型所定义的函数。非虚函数总是在编译时根据调用该函数的对象，引用或指针的类型而确定。如果调用虚函数，则直到运行时才能确定调用哪个函数，运行的虚函数是引用所绑定或指针所指向的对象所属类型定义的版本。虚函数必须是基类的非静态成员函数。虚函数的作用是实现动态联编，也就是在程序的运行阶段动态地选择合适的成员函数，在定义了虚函数后，可以在基类的派生类中对虚函数重新定义，在派生类中重新定义的函数应与虚函数具有相同的形参个数和形参类型。以实现统一的接口，不同定义过程。如果在派生类中没有对虚函数重新定义，则它继承其基类的虚函数。

    ```
    class Person{
        public:
            //虚函数
            virtual void GetName(){
                cout<<"PersonName:xiaosi"<<endl;
            };
    };
    class Student:public Person{
        public:
            void GetName(){
                cout<<"StudentName:xiaosi"<<endl;
            };
    };
    int main(){
        //指针
        Person *person = new Student();
        //基类调用子类的函数
        person->GetName();//StudentName:xiaosi
    }
    ```

    虚函数（Virtual Function）是通过一张虚函数表（Virtual Table）来实现的。简称为V-Table。在这个表中，主是要一个类的虚函数的地址表，这张表解决了继承、覆盖的问题，保证其容真实反应实际的函数。这样，在有虚函数的类的实例中这个表被分配在了这个实例的内存中，所以，当我们用父类的指针来操作一个子类的时候，这张虚函数表就显得由为重要了，它就像一个地图一样，指明了实际所应该调用的函数。

2. 纯虚函数是在基类中声明的虚函数，它在基类中没有定义，但要求任何派生类都要定义自己的实现方法。在基类中实现纯虚函数的方法是在函数原型后加“=0” virtualvoid GetName() =0。在很多情况下，基类本身生成对象是不合情理的。例如，动物作为一个基类可以派生出老虎、孔雀等子类，但动物本身生成对象明显不合常理。为了解决上述问题，将函数定义为纯虚函数，则编译器要求在派生类中必须予以重写以实现多态性。同时含有纯虚拟函数的类称为抽象类，它不能生成对象。这样就很好地解决了上述两个问题。将函数定义为纯虚函数能够说明，该函数为后代类型提供了可以覆盖的接口，但是这个类中的函数绝不会调用。声明了纯虚函数的类是一个抽象类。所以，用户不能创建类的实例，只能创建它的派生类的实例。必须在继承类中重新声明函数（不要后面的＝0）否则该派生类也不能实例化，而且它们在抽象类中往往没有定义。定义纯虚函数的目的在于，使派生类仅仅只是继承函数的接口。纯虚函数的意义，让所有的类对象（主要是派生类对象）都可以执行纯虚函数的动作，但类无法为纯虚函数提供一个合理的缺省实现。所以类纯虚函数的声明就是在告诉子类的设计者，“你必须提供一个纯虚函数的实现，但我不知道你会怎样实现它”。

```
//抽象类
class Person{
    public:
        //纯虚函数
        virtual void GetName()=0;
};
class Student:public Person{
    public:
        Student(){
        };
        void GetName(){
            cout<<"StudentName:xiaosi"<<endl;
        };
};
int main(){
    Student student;
}
```



#### 1.3.22 说说纯虚函数能实例化吗，为什么？派生类要实现吗，为什么？

**参考回答**

1. 纯虚函数不可以实例化，但是可以用其派生类实例化，示例如下：

    ```C++
    class Base { public:  virtual void func() = 0; }; 
    ```

    ```C++
    #include<iostream>  
    using namespace std;  
    class Base {     public:     virtual void func() = 0; };  class Derived :public Base {     public:     void func() override     {         cout << "哈哈" << endl;     } };  int main() {     Base *b = new Derived();     b->func();      return 0; }
    ```

2. 虚函数的原理采用 vtable。类中含有纯虚函数时，其vtable 不完全，有个空位。

    即“纯虚函数在类的vftable表中对应的表项被赋值为0。也就是指向一个不存在的函数。由于编译器绝对不允许有调用一个不存在的函数的可能，所以该类不能生成对象。在它的派生类中，除非重写此函数，否则也不能生成对象。”

    所以纯虚函数不能实例化。

3. 纯虚函数是在基类中声明的虚函数，它要求任何派生类都要定义自己的实现方法，以实现多态性。

4. 定义纯虚函数是为了实现一个接口，用来规范派生类的行为，也即规范继承这个类的程序员必须实现这个函数。派生类仅仅只是继承函数的接口。纯虚函数的意义在于，让所有的类对象（主要是派生类对象）都可以执行纯虚函数的动作，但基类无法为纯虚函数提供一个合理的缺省实现。所以类纯虚函数的声明就是在告诉子类的设计者，“你必须提供一个纯虚函数的实现，但我不知道你会怎样实现它”。

#### 1.3.23 说说C++中虚函数与纯虚函数的区别

**参考回答**

1. 虚函数和纯虚函数可以定义在同一个类中，含有纯虚函数的类被称为抽象类，而只含有虚函数的类不能被称为抽象类。
2. 虚函数可以被直接使用，也可以被子类重载以后，以多态的形式调用，而纯虚函数必须在子类中实现该函数才可以使用，因为纯虚函数在基类有声明而没有定义。
3. 虚函数和纯虚函数都可以在子类中被重载，以多态的形式被调用。
4. 虚函数和纯虚函数通常存在于抽象基类之中，被继承的子类重载，目的是提供一个统一的接口。
5. 虚函数的定义形式：virtual{};纯虚函数的定义形式：virtual { } = 0;在虚函数和纯虚函数的定义中不能有static标识符，原因很简单，被static修饰的函数在编译时要求前期绑定,然而虚函数却是动态绑定，而且被两者修饰的函数生命周期也不一样。

**答案解析**

1. 我们举个虚函数的例子：

    ```
    class A { public:     virtual void foo()     {         cout<<"A::foo() is called"<<endl;     } }; class B:public A { public:     void foo()     {         cout<<"B::foo() is called"<<endl;     } }; int main(void) {     A *a = new B();     a->foo();   // 在这里，a虽然是指向A的指针，但是被调用的函数(foo)却是B的!     return 0; }
    ```

    这个例子是虚函数的一个典型应用，通过这个例子，也许你就对虚函数有了一些概念。它虚就虚在所谓“推迟联编”或者“动态联编”上，一个类函数的调用并不是在编译时刻被确定的，而是在运行时刻被确定的。由于编写代码的时候并不能确定被调用的是基类的函数还是哪个派生类的函数，所以被成为“虚”函数。 虚函数只能借助于指针或者引用来达到多态的效果。

2. 纯虚函数是在基类中声明的虚函数，它在基类中没有定义，但要求任何派生类都要定义自己的实现方法。在基类中实现纯虚函数的方法是在函数原型后加“=0”

    virtual void funtion1()=0

    为了方便使用多态特性，我们常常需要在基类中定义虚拟函数。

    在很多情况下，**基类本身生成对象是不合情理的**。例如，动物作为一个基类可以派生出老虎、孔雀等子类，但动物本身生成对象明显不合常理。

    为了解决上述问题，引入了纯虚函数的概念，将函数定义为纯虚函数（方法：virtual ReturnType Function()= 0;），则编译器要求在派生类中必须予以重写以实现多态性。**同时含有纯虚拟函数的类称为抽象类，它不能生成对象**。这样就很好地解决了上述两个问题。 声明了纯虚函数的类是一个抽象类。所以，用户不能创建类的实例，只能创建它的派生类的实例。

    纯虚函数最显著的特征是：它们必须在继承类中重新声明函数（不要后面的＝0，否则该派生类也不能实例化），而且它们在抽象类中往往没有定义。

    定义纯虚函数的目的在于，使派生类仅仅只是继承函数的接口。

    纯虚函数的意义，让所有的类对象（主要是派生类对象）都可以执行纯虚函数的动作，但类无法为纯虚函数提供一个合理的缺省实现。所以类纯虚函数的声明就是在告诉子类的设计者，“你必须提供一个纯虚函数的实现，但我不知道你会怎样实现它”。

#### 1.3.24 说说 C++ 中什么是菱形继承问题，如何解决

**参考回答**

1. 下面的图表可以用来解释菱形继承问题。

![img](https://uploadfiles.nowcoder.com/images/20220225/4107856_1645788250019/669F46EC1CA09D9F687FFD9A8EC4CFEE)

- 假设我们有类B和类C，它们都继承了相同的类A。另外我们还有类D，类D通过多重继承机制继承了类B和类C。因为上述图表的形状类似于菱形，因此这个问题被形象地称为菱形继承问题。现在，我们将上面的图表翻译成具体的代码：

    ```
    /*  *Animal类对应于图表的类A* */ class Animal { /* ... */ }; // 基类 {     int weight;      public:     int getWeight() { return weight; } };  class Tiger : public Animal { /* ... */ }; class Lion : public Animal { /* ... */ } class Liger : public Tiger, public Lion { /* ... */ }
    ```

    在上面的代码中，我们给出了一个具体的菱形继承问题例子。Animal类对应于最顶层类（图表中的A），Tiger和Lion分别对应于图表的B和C，Liger类（狮虎兽，即老虎和狮子的杂交种)对应于D。

    现在，问题是如果我们有这种继承结构会出现什么样的问题。

    看看下面的代码后再来回答问题吧。

    ```
      int main( )  {   Liger lg;   /*编译错误，下面的代码不会被任何C++编译器通过 */   int weight = lg.getWeight();    }
    ```

- 在我们的继承结构中，我们可以看出Tiger和Lion类都继承自Animal基类。所以问题是：因为Liger多重继承了Tiger和Lion类，因此Liger类会有两份Animal类的成员（数据和方法），Liger对象"lg"会包含Animal基类的两个子对象。

    所以，你会问Liger对象有两个Animal基类的子对象会出现什么问题？再看看上面的代码-调用"lg.getWeight()"将会导致一个编译错误。这是因为编译器并不知道是调用Tiger类的getWeight()还是调用Lion类的getWeight()。所以，调用getWeight方法是不明确的，因此不能通过编译。

1. 我们给出了菱形继承问题的解释，但是现在我们要给出一个菱形继承问题的解决方案。如果Lion类和Tiger类在分别继承Animal类时都用virtual来标注，对于每一个Liger对象，C++会保证只有一个Animal类的子对象会被创建。看看下面的代码:

    ```
    class Tiger : virtual public Animal { /* ... */ }; class Lion : virtual public Animal { /* ... */ };
    ```

- 你可以看出唯一的变化就是我们在类Tiger和类Lion的声明中增加了"virtual"关键字。现在类Liger对象将会只有一个Animal子对象，下面的代码编译正常:

    ```
    int main( ) {  Liger lg;  /*既然我们已经在Tiger和Lion类的定义中声明了"virtual"关键字，于是下面的代码编译OK */  int weight = lg.getWeight(); }
    ```

#### 1.3.25 请问构造函数中的能不能调用虚方法

**参考回答**

1. **不要在构造函数中调用虚方法**，从语法上讲，调用完全没有问题，但是从效果上看，往往不能达到需要的目的。

    派生类对象构造期间进入基类的构造函数时，对象类型变成了基类类型，而不是派生类类型。

    同样，进入基类析构函数时，对象也是基类类型。

    所以，虚函数始终仅仅调用基类的虚函数（如果是基类调用虚函数），不能达到多态的效果，所以放在构造函数中是没有意义的，而且往往不能达到本来想要的效果。

#### 1.3.26 请问拷贝构造函数的参数是什么传递方式，为什么

**参考回答**

1. **拷贝构造函数的参数必须使用引用传递**

2. 如果拷贝构造函数中的参数不是一个引用，即形如CClass(const CClass c_class)，那么就相当于采用了传值的方式(pass-by-value)，而传值的方式会调用该类的拷贝构造函数，从而造成无穷递归地调用拷贝构造函数。因此拷贝构造函数的参数必须是一个引用。

    需要澄清的是，传指针其实也是传值，如果上面的拷贝构造函数写成CClass(const CClass* c_class)，也是不行的。事实上，只有传引用不是传值外，其他所有的传递方式都是传值。

#### 1.3.27 说说类方法和数据的权限有哪几种

**参考回答**

1. C++通过 public、protected、private 三个关键字来控制成员变量和成员函数的访问权限，它们分别表示公有的、受保护的、私有的，被称为成员访问限定符。

    | 关键字    | 权限                           |
    | :-------- | :----------------------------- |
    | public    | 可以被任意实体访问             |
    | protected | 只允许子类及本类的成员函数访问 |
    | private   | 只允许本类的成员函数访问       |

2. 下面介绍一个例子。

    父类：

    ```
    class Person { public:     Person(const string& name, int age) : m_name(name), m_age(age)     {     }      void ShowInfo()     {         cout << "姓名：" << m_name << endl;         cout << "年龄：" << m_age << endl;     }      protected:     string m_name;     //姓名  private:     int m_age;      //年龄 };
    ```

    子类：

    ```
    class Teacher : public Person
    {
    public:
        Teacher(const string& name, int age, const string& title)
             : Person(name, age), m_title(title)
        {
        }
    
        void ShowTeacherInfo()
        {
            ShowInfo();                             //正确，public属性子类可见
            cout << "姓名：" << m_name << endl;        //正确，protected属性子类可见
            cout << "年龄：" << m_age << endl;     //错误，private属性子类不可见
    
            cout << "职称：" << m_title << endl;   //正确，本类中可见自己的所有成员
        }
    
    private:
        string  m_title;        //职称
    };
    ```

    调用方：

    ```
     void test()
     {
         Person person("张三", 22);
         person.ShowInfo();                  //public属性,对外部可见
         cout << person.m_name << endl;      //protected属性,对外部不可见
         cout << person.m_age << endl;       //private属性,对外部不可见
     }
    ```

#### 1.3.28 如何理解抽象类？

**参考回答**

1. 抽象类的定义如下：

    纯虚函数是在基类中声明的虚函数，它在基类中没有定义，但要求任何派生类都要定义自己的实现方法。在基类中实现纯虚函数的方法是在函数原型后加“=0”，有虚函数的类就叫做抽象类。

2. 抽象类有如下几个特点：

    1）抽象类只能用作其他类的基类，**不能建立抽象类对象**。

    2）抽象类不能用作参数类型、函数返回类型或显式转换的类型。

    3）可以定义指向抽象类的指针和引用，此指针可以指向它的派生类，进而实现多态性。

#### 1.3.29 什么是多态？除了虚函数，还有什么方式能实现多态？

**参考回答**

1. 多态是面向对象的重要特性之一，它是一种行为的封装，就是不同对象对同一行为会有不同的状态。(举例 : 学生和成人都去买票时,学生会打折,成人不会)

2. 多态是以封装和继承为基础的。在C++中多态分为静态多态（早绑定）和动态多态（晚绑定）两种，其中动态多态是通过虚函数实现，静态多态通过函数重载实现，代码如下：

    ```
    class A
    {
    public:    
        void do(int a);    
        void do(int a, int b);
    };
    ```

#### 1.3.30 简述一下虚析构函数，什么作用

**参考回答**

1. 虚析构函数，是将基类的析构函数声明为virtual，举例如下：

    ```
    class TimeKeeper
    {
    public:    
        TimeKeeper() {}        
        virtual ~TimeKeeper() {}    
    };
    ```

2. 虚析构函数的主要作用是防止内存泄露。

    定义一个基类的指针p，在delete p时，如果基类的析构函数是虚函数，这时只会看p所赋值的对象，如果p赋值的对象是派生类的对象，就会调用派生类的析构函数（毫无疑问，在这之前也会先调用基类的构造函数，在调用派生类的构造函数，然后调用派生类的析构函数，基类的析构函数，所谓先构造的后释放）；如果p赋值的对象是基类的对象，就会调用基类的析构函数，这样就不会造成内存泄露。

    如果基类的析构函数不是虚函数，在delete p时，调用析构函数时，只会看指针的数据类型，而不会去看赋值的对象，这样就会造成内存泄露。

**答案解析**

- 我们创建一个TimeKeeper基类和一些及其它的派生类作为不同的计时方法

    ```
    class TimeKeeper
    {
    public:
        TimeKeeper() {}
        ~TimeKeeper() {}  //非virtual的
    };
    
    //都继承与TimeKeeper
    class AtomicClock :public TimeKeeper{};
    class WaterClock :public TimeKeeper {};
    class WristWatch :public TimeKeeper {};
    ```

- 如果客户想要在程序中使用时间，不想操作时间如何计算等细节，这时候我们可以设计factory（工厂）函数，让函数返回指针指向一个计时对象。该函数返回一个基类指针，这个基类指针是指向于派生类对象的

    ```
    TimeKeeper* getTimeKeeper()
    {
        //返回一个指针，指向一个TimeKeeper派生类的动态分配对象
    }
    ```

- 因为函数返回的对象存在于堆中，因此为了**在不使用时我们需要使用释放该对象（delete）**

    ```
    TimeKeeper* ptk = getTimeKeeper();
    delete ptk;
    ```

- 此处基类的析构函数是非virtual的，因此**通过一个基类指针删除派生类对象是错误的**

- **解决办法：** 将基类的析构函数改为virtual就正确了

    ```
    class TimeKeeper
    {
    public:
        TimeKeeper() {}
        virtual ~TimeKeeper() {}
    };
    ```

- 声明为virtual之后，通过**基类指针删除派生类对象就会释放整个对象（基类+派生类）**

#### 1.3.31 说说什么是虚基类，可否被实例化？

**参考回答**

1. 在被继承的类前面加上virtual关键字，这时被继承的类称为虚基类，代码如下：

    ```C++
    class A
    class B1:public virtual A;
    class B2:public virtual A;
    class D:public B1,public B2;
    ```

2. 虚继承的类可以被实例化，举例如下：

    ```C++
    class Animal {/* ... */ };
    class Tiger : virtual public Animal { /* ... */ };
    class Lion : virtual public Animal { /* ... */ }
    ```

    ```C++
    int main( )
    {
        Liger lg;
    
        /*既然我们已经在Tiger和Lion类的定义中声明了"virtual"关键字，于是下面的代码编译OK */
        int weight = lg.getWeight();
    }
    ```

#### 1.3.32 简述一下拷贝赋值和移动赋值？

**参考回答**

1. 拷贝赋值是通过拷贝构造函数来赋值，在创建对象时，使用同一类中之前创建的对象来初始化新创建的对象。

2. 移动赋值是通过移动构造函数来赋值，二者的主要区别在于

    1）拷贝构造函数的形参是一个左值引用，而移动构造函数的形参是一个右值引用；

    2）拷贝构造函数完成的是整个对象或变量的拷贝，而移动构造函数是生成一个指针指向源对象或变量的地址，接管源对象的内存，相对于大量数据的拷贝节省时间和内存空间。

#### 1.3.33仿函数了解吗？有什么作用

**参考回答**

1. 仿函数（functor）又称为函数对象（function object）是一个能行使函数功能的类。仿函数的语法几乎和我们普通的函数调用一样，不过作为仿函数的类，都必须重载operator()运算符，举个例子：

```C++
class Func{
public:
    void operator() (const string& str) const {
        cout<<str<<endl;
    }
};

Func myFunc;
myFunc("helloworld!");

>>>helloworld!
```

1. 仿函数既能想普通函数一样传入给定数量的参数，还能存储或者处理更多我们需要的有用信息。我们可以举个例子：

    假设有一个vector<string>，你的任务是统计长度小于5的string的个数，如果使用count_if函数的话，你的代码可能长成这样：

    ```C++
     bool LengthIsLessThanFive(const string& str) {
         return str.length()<5;    
     }
     int res=count_if(vec.begin(), vec.end(), LengthIsLessThanFive);
    ```

    其中count_if函数的第三个参数是一个函数指针，返回一个bool类型的值。一般的，如果需要将特定的阈值长度也传入的话，我们可能将函数写成这样：

    ```C++
     bool LenthIsLessThan(const string& str, int len) {
         return str.length()<len;
     }
    ```

    这个函数看起来比前面一个版本更具有一般性，但是他不能满足count_if函数的参数要求：count_if要求的是unary function（仅带有一个参数）作为它的最后一个参数。如果我们使用仿函数，是不是就豁然开朗了呢：

    ```C++
     class ShorterThan {
     public:
         explicit ShorterThan(int maxLength) : length(maxLength) {}
         bool operator() (const string& str) const {
             return str.length() < length;
         }
     private:
         const int length;
     };
    ```

#### 1.3.34 C++ 中哪些函数不能被声明为虚函数？

**参考回答**

常见的不不能声明为虚函数的有：**普通函数（非成员函数），静态成员函数，内联成员函数，构造函数，友元函数**。

1. 为什么C++不支持普通函数为虚函数？

   普通函数（非成员函数）只能被overload，不能被override，声明为虚函数也没有什么意思，因此编译器会在编译时绑定函数。

1. 为什么C++不支持构造函数为虚函数？

    这个原因很简单，主要是从语义上考虑，所以不支持。**因为构造函数本来就是为了明确初始化对象成员才产生的**，然而virtual function主要是为了再不完全了解细节的情况下也能正确处理对象。另外，virtual函数是在不同类型的对象产生不同的动作，现在对象还没有产生，如何使用virtual函数来完成你想完成的动作。（这不就是典型的悖论）

    构造函数用来创建一个新的对象,而虚函数的运行是建立在对象的基础上,在构造函数执行时,对象尚未形成,所以不能将构造函数定义为虚函数

2. 为什么C++不支持内联成员函数为虚函数？

    其实很简单，那内联函数就是为了在代码中直接展开，减少函数调用花费的代价，虚函数是为了在继承后对象能够准确的执行自己的动作，这是不可能统一的。（再说了，***inline函数在编译时被展开**，**虚函数在运行时才能动态的绑定函数***）

    内联函数是在编译时期展开,而虚函数的特性是运行时才动态联编,所以两者矛盾,不能定义内联函数为虚函数

3. 为什么C++不支持静态成员函数为虚函数？

    这也很简单，静态成员函数对于每个类来说只有一份代码，所有的对象都共享这一份代码，他也没有要动态绑定的必要性。

    静态成员函数属于一个类而非某一对象,没有this指针,它无法进行对象的判别

4. 为什么C++不支持友元函数为虚函数？

    因为C++不支持友元函数的继承，对于没有继承特性的函数没有虚函数的说法。

#### 1.3.35 解释下 C++ 中类模板和模板类的区别

**参考回答**

1. 类模板是模板的定义，不是一个实实在在的类，定义中用到通用类型参数
2. 模板类是实实在在的类定义，是类模板的实例化。类定义中参数被实际类型所代替。

**答案解析**

1. 类模板的类型参数可以有一个或多个，每个类型前面都必须加class，如template <class T1,class T2>class someclass{…};在定义对象时分别代入实际的类型名，如  someclass<int,double> obj;
2. 和使用类一样，使用类模板时要注意其作用域，只能在其有效作用域内用它定义对象。
3. 模板可以有层次，一个类模板可以作为基类，派生出派生模板类。

#### 1.3.36 虚函数表里存放的内容是什么时候写进去的？

**参考回答**

1. 虚函数表是一个存储虚函数地址的数组,以NULL结尾。**虚表（vftable）在编译阶段生成**，对象内存空间开辟以后，写入对象中的 vfptr，然后调用构造函数。即：**虚表在构造函数之前写入**
2. 除了在构造函数之前写入之外，**我们还需要考虑到虚表的二次写入机制**，通过此机制让每个对象的虚表指针都能准确的指向到自己类的虚表，为实现动多态提供支持。



### 1.4 STL

#### 1.4.1 请说说 STL 的基本组成部分

**参考回答**

  标准模板库（Standard Template Library,简称STL）简单说，就是一些常用数据结构和算法的模板的集合。

  **广义上讲**，STL分为3类：Algorithm**（算法）**、Container**（容器）**和Iterator**（迭代器）**，容器和算法通过迭代器可以进行无缝地连接。

  **详细的说**，STL由6部分组成：**容器**(Container)、**算法**（Algorithm）、 **迭代器**（Iterator）、**仿函数**（Function object）、**适配器**（Adaptor）、**空间配制器**（Allocator）。

**答案解析**

  标准模板库STL主要由6大组成部分：

1. **容器(Container)**  

      是一种数据结构， 如list, vector, 和deques，以模板类的方法提供。为了访问容器中的数据，可以使用由容器类输出的迭代器。

2. **算法（Algorithm）**

      是用来操作容器中的数据的模板函数。例如，STL用sort()来对一 个vector中的数据进行排序，用find()来搜索一个list中的对象， 函数本身与他们操作的数据的结构和类型无关，因此他们可以用于从简单数组到高度复杂容器的任何数据结构上。

3. **迭代器（Iterator）**

      提供了访问容器中对象的方法。例如，可以使用一对迭代器指定list或vector中的一定范围的对象。 迭代器就如同一个指针。事实上，C++ 的指针也是一种迭代器。 但是，迭代器也可以是那些定义了operator*()以及其他类似于指针的操作符方法的类对象;

4. **仿函数（Function object）**

      仿函数又称之为函数对象， 其实就是重载了操作符的struct,没有什么特别的地方。

5. **适配器（Adaptor）**

      简单的说就是一种接口类，专门用来修改现有类的接口，提供一中新的接口；或调用现有的函数来实现所需要的功能。主要包括3中适配器Container Adaptor、Iterator Adaptor、Function Adaptor。

6. **空间配制器（Allocator）**

      为STL提供空间配置的系统。其中主要工作包括两部分：

    （1）对象的创建与销毁；

    （2）内存的获取与释放。

#### 1.4.2 请说说 STL 中常见的容器，并介绍一下实现原理

**参考回答**

  容器可以用于存放各种类型的数据（基本类型的变量，对象等）的数据结构，都是模板类，分为顺序容器、关联式容器、容器适配器三种类型，三种类型容器特性分别如下：

1. 顺序容器

      容器并非排序的，元素的插入位置同元素的值无关。包含vector、deque、list，具体实现原理如下：

    （1）vector  头文件<vector>

    ​      动态数组。元素在内存连续存放。随机存取任何元素都能在常数时间完成。在尾端增删元素具有较佳的性能。

    （2）deque  头文件<deque>

      双向队列。元素在内存连续存放。随机存取任何元素都能在常数时间完成（仅次于vector）。在两端增删元素具有较佳的性能（大部分情况下是常数时间）。

    （3）list  头文件<list>

       双向链表。元素在内存不连续存放。在任何位置增删元素都能在常数时间完成。不支持随机存取。

2. 关联式容器

      元素是排序的；插入任何元素，都按相应的排序规则来确定其位置；在查找时具有非常好的性能；通常以平衡二叉树的方式实现。包含set、multiset、map、multimap，具体实现原理如下：

    （1）set/multiset  头文件<set>

    ​    set 即集合。set中不允许相同元素，multiset中允许存在相同元素。

    （2）map/multimap  头文件<map>

    ​    map与set的不同在于map中存放的元素有且仅有两个成员变，一个名为first,另一个名为second, map根据first值对元素从小到大排序，并可快速地根据first来检索元素。

      **注意：**map同multimap的不同在于是否允许相同first值的元素。

3. 容器适配器

      封装了一些基本的容器，使之具备了新的函数功能，比如把deque封装一下变为一个具有stack功能的数据结构。这新得到的数据结构就叫适配器。包含stack,queue,priority_queue，具体实现原理如下：

    （1）stack  头文件<stack>

    ​    栈是项的有限序列，并满足序列中被删除、检索和修改的项只能是最进插入序列的项（栈顶的项）。后进先出。

    （2）queue  头文件<queue>

    ​    队列。插入只可以在尾部进行，删除、检索和修改只允许从头部进行。先进先出。

    （3）priority_queue  头文件<queue>

    ​    优先级队列。内部维持某种有序，然后确保优先级最高的元素总是位于头部。最高优先级元素总是第一个出列。

#### 1.4.3 说说 STL 中 map hashtable deque list 的实现原理

**参考回答**

  map、hashtable、deque、list实现机理分别为红黑树、函数映射、双向队列、双向链表，他们的特性分别如下：

1. map实现原理

      map内部实现了一个**红黑树**（红黑树是非严格平衡的二叉搜索树，而AVL是严格平衡二叉搜索树），红黑树有自动排序的功能，因此map内部所有元素都是有序的，红黑树的每一个节点都代表着map的一个元素。因此，对于map进行的查找、删除、添加等一系列的操作都相当于是对红黑树进行的操作。map中的元素是按照二叉树（又名二叉查找树、二叉排序树）存储的，特点就是左子树上所有节点的键值都小于根节点的键值，右子树所有节点的键值都大于根节点的键值。使用中序遍历可将键值按照从小到大遍历出来。

2. hashtable（也称散列表，直译作哈希表）实现原理

      hashtable采用了**函数映射的思想**记录的存储位置与记录的关键字关联起来，从而能够很快速地进行查找。这决定了哈希表特殊的数据结构，它同数组、链表以及二叉排序树等相比较有很明显的区别，它能够快速定位到想要查找的记录，而不是与表中存在的记录的关键字进行比较来进行查找。

3. deque实现原理

      deque内部实现的是一个**双向队列**。元素在内存连续存放。随机存取任何元素都在常数时间完成（仅次于vector）。所有适用于vector的操作都适用于deque。在两端增删元素具有较佳的性能（大部分情况下是常数时间）。

4. list实现原理

      list内部实现的是一个**双向链表**。元素在内存不连续存放。在任何位置增删元素都能在常数时间完成。不支持随机存取。无成员函数，给定一个下标i，访问第i个元素的内容，只能从头部挨个遍历到第i个元素。

#### 1.4.4 请你来介绍一下 STL 的空间配置器（allocator）

**参考回答**

  一般情况下,一个程序包括数据结构和相应的算法，而数据结构作为存储数据的组织形式，与内存空间有着密切的联系。在C++ STL中，空间配置器便是用来实现内存空间(一般是内存，也可以是硬盘等空间)分配的工具，他与容器联系紧密，每一种容器的空间分配都是通过空间分配器alloctor实现的。

**答案解析**

1. 两种C++类对象实例化方式的异同

      在c++中，创建类对象一般分为两种方式：一种是直接利用构造函数,直接构造类对象，如 Test test()；另一种是通过new来实例化一个类对象，如 Test *pTest = new Test；那么，这两种方式有什么异同点呢？

    我们知道，内存分配主要有三种方式：

    （1） 静态存储区分配：内存在程序编译的时候已经分配好，这块内存在程序的整个运行空间内都存在。如全局变量,静态变量等。

    （2） 栈空间分配：程序在运行期间，函数内的局部变量通过栈空间来分配存储（函数调用栈），当函数执行完毕返回时，相对应的栈空间被立即回收。主要是局部变量。 （3）堆空间分配：程序在运行期间，通过在堆空间上为数据分配存储空间，通过malloc和new创建的对象都是从堆空间分配内存，这类空间需要程序员自己来管理，必须通过free()或者是delete()函数对堆空间进行释放，否则会造成内存溢出。

    那么，从**内存空间分配的角度**来对这两种方式的区别，就比较容易区分:

    （1）对于第一种方式来说，是直接通过调用Test类的构造函数来实例化Test类对象的,如果该实例化对象是一个局部变量，则其是在栈空间分配相应的存储空间。 （2）对于第二种方式来说,就显得比较复杂。这里主要以new类对象来说明一下。new一个类对象,其实是执行了两步操作：首先,调用new在堆空间分配内存,然后调用类的构造函数构造对象的内容；同样，使用delete释放时，也是经历了两个步骤：首先调用类的析构函数释放类对象，然后调用delete释放堆空间。

2. C++ STL空间配置器实现

    很容易想象，为了实现空间配置器，完全可以利用new和delete函数并对其进行封装实现STL的空间配置器，的确可以这样。但是，为了最大化提升效率，SGI STL版本并没有简单的这样做，而是采取了一定的措施，实现了更加高效复杂的空间分配策略。由于以上的构造都分为两部分，所以，在SGI STL中，将对象的构造切分开来，分成空间配置和对象构造两部分。

    ​    内存配置操作: 通过alloc::allocate()实现     内存释放操作: 通过alloc::deallocate()实现     对象构造操作: 通过::construct()实现     对象释放操作: 通过::destroy()实现

      关于内存空间的配置与释放，SGI STL采用了两级配置器：一级配置器主要是考虑大块内存空间，利用malloc和free实现；二级配置器主要是考虑小块内存空间而设计的（为了最大化解决内存碎片问题，进而提升效率），采用链表free_list来维护内存池（memory pool），free_list通过union结构实现，空闲的内存块互相挂接在一块，内存块一旦被使用，则被从链表中剔除，易于维护。

#### 1.4.5 STL 容器用过哪些，查找的时间复杂度是多少，为什么？

**参考回答**

  STL中常用的容器有vector、deque、list、map、set、multimap、multiset、unordered_map、unordered_set等。容器底层实现方式及时间复杂度分别如下：

1. vector

    采用一维数组实现，元素在内存连续存放，不同操作的时间复杂度为：

    插入: O(N)

    查看: O(1)

    删除: O(N)

2. deque

    采用双向队列实现，元素在内存连续存放，不同操作的时间复杂度为：

    插入: O(N)

    查看: O(1)

    删除: O(N)

3. list

    采用双向链表实现，元素存放在堆中，不同操作的时间复杂度为：

    插入: O(1)

    查看: O(N)

    删除: O(1)

4. map、set、multimap、multiset

    上述四种容器采用红黑树实现，红黑树是平衡二叉树的一种。不同操作的时间复杂度近似为:

    插入: O(logN)

    查看: O(logN)

    删除: O(logN)

5. unordered_map、unordered_set、unordered_multimap、 unordered_multiset

    上述四种容器采用哈希表实现，不同操作的时间复杂度为： 插入: O(1)，最坏情况O(N)

    查看: O(1)，最坏情况O(N)

    删除: O(1)，最坏情况O(N)

    **注意：**容器的时间复杂度取决于其底层实现方式。

#### 1.4.6 迭代器用过吗？什么时候会失效？

**参考回答**

  用过，常用容器迭代器失效情形如下。

1. 对于序列容器vector，deque来说，使用erase后，后边的每个元素的迭代器都会失效，后边每个元素都往前移动一位，erase返回下一个有效的迭代器。
2. 对于关联容器map，set来说，使用了erase后，当前元素的迭代器失效，但是其结构是红黑树，删除当前元素，不会影响下一个元素的迭代器，所以在调用erase之前，记录下一个元素的迭代器即可。
3. 对于list来说，它使用了不连续分配的内存，并且它的erase方法也会返回下一个有效的迭代器，因此上面两种方法都可以使用。

#### 1.4.7 说一下STL中迭代器的作用，有指针为何还要迭代器？

**参考回答**

1. 迭代器的作用

    （1）用于指向顺序容器和关联容器中的元素

    （2）通过迭代器可以读取它指向的元素

    （3）通过非const迭代器还可以修改其指向的元素

2. 迭代器和指针的区别

      **迭代器不是指针，是类模板，表现的像指针。**他只是模拟了指针的一些功能，重载了指针的一些操作符，-->、++、--等。迭代器封装了指针，是一个”可遍历STL（ Standard Template Library）容器内全部或部分元素”的对象，**本质**是封装了原生指针，是指针概念的一种提升，提供了比指针更高级的行为，相当于一种智能指针，他可以根据不同类型的数据结构来实现不同的++，--等操作。

      **迭代器返回的是对象引用而不是对象的值**，所以cout只能输出迭代器使用取值后的值而不能直接输出其自身。

3. 迭代器产生的原因

      Iterator类的访问方式就是把不同集合类的访问逻辑抽象出来，使得不用暴露集合内部的结构而达到循环遍历集合的效果。

**答案解析**

1. 迭代器

      Iterator（迭代器）模式又称游标（Cursor）模式，用于提供一种方法**顺序访问一个聚合对象中各个元素, 而又不需暴露该对象的内部表示**。 或者这样说可能更容易理解：Iterator模式是运用于聚合对象的一种模式，通过运用该模式，使得我们**可以在不知道对象内部表示的情况下，按照一定顺序（由iterator提供的方法）访问聚合对象中的各个元素**。 由于Iterator模式的以上特性：与聚合对象耦合，在一定程度上限制了它的广泛运用，一般仅用于底层聚合支持类，如STL的list、vector、stack等容器类及ostream_iterator等扩展Iterator。

  \2. 迭代器示例：

```
#include <vector> #include <iostream> using namespace std;  int main() {  vector<int> v; //一个存放int元素的数组，一开始里面没有元素  v.push_back(1);  v.push_back(2);  v.push_back(3);  v.push_back(4);  vector<int>::const_iterator i; //常量迭代器  for (i = v.begin(); i != v.end(); ++i) //v.begin()表示v第一个元素迭代器指针，++i指向下一个元素   cout << *i << ","; //*i表示迭代器指向的元素  cout << endl;   vector<int>::reverse_iterator r; //反向迭代器  for (r = v.rbegin(); r != v.rend(); r++)   cout << *r << ",";  cout << endl;  vector<int>::iterator j; //非常量迭代器  for (j = v.begin();j != v.end();j++)   *j = 100;  for (i = v.begin();i != v.end();i++)   cout << *i << ",";  return 0; }  /*      运行结果：   1,2,3,4,   4,3,2,1,   100,100,100,100, */    
```

#### 1.4.8 说说 STL 迭代器是怎么删除元素的

**参考回答**

  这是主要考察迭代器失效的问题。

1. 对于序列容器vector，deque来说，使用erase后，后边的每个元素的迭代器都会失效，后边每个元素都往前移动一位，erase返回下一个有效的迭代器；
2. 对于关联容器map，set来说，使用了erase后，当前元素的迭代器失效，但是其结构是红黑树，删除当前元素，不会影响下一个元素的迭代器，所以在调用erase之前，记录下一个元素的迭代器即可；
3. 对于list来说，它使用了不连续分配的内存，并且它的erase方法也会返回下一个有效的迭代器，因此上面两种方法都可以使用。

**答案解析**

  容器上迭代器分类如下表（详细实现过程请翻阅相关资料详细了解）：

|      容器      | 容器上的迭代器类别 |
| :------------: | :----------------: |
|     vector     |      随机访问      |
|     deque      |      随机访问      |
|      list      |        双向        |
|  set/multiset  |        双向        |
|  map/multimap  |        双向        |
|     stack      |    不支持迭代器    |
|     queue      |    不支持迭代器    |
| priority_queue |    不支持迭代器    |

#### 1.4.9 说说 STL 中 resize 和 reserve 的区别

**参考回答**

1. 首先必须弄清楚两个概念：

    （1）capacity：该值在容器初始化时赋值，指的是容器能够容纳的最大的元素的个数。还不能通过下标等访问，因为此时容器中还没有创建任何对象。

    （2）size：指的是此时容器中实际的元素个数。可以通过下标访问0-(size-1)范围内的对象。

2. resize和reserve区别主要有以下几点：

    （1）resize既分配了空间，也创建了对象；reserve表示容器预留空间，但并不是真正的创建对象，需要通过insert（）或push_back（）等创建对象。

    （2）resize既修改capacity大小，也修改size大小；reserve只修改capacity大小，不修改size大小。

    （3）两者的形参个数不一样。 resize带两个参数，一个表示容器大小，一个表示初始值（默认为0）；reserve只带一个参数，表示容器预留的大小。

**答案解析**

  **问题延伸：**

  resize 和 reserve 既有差别，也有共同点。两个接口的**共同点**是**它们都保证了vector的空间大小(capacity)最少达到它的参数所指定的大小。**下面就他们的细节进行分析。

  为实现resize的语义，resize接口做了两个保证：

​    （1）保证区间[0, new_size)范围内数据有效，如果下标index在此区间内，vector[indext]是合法的；

​    （2）保证区间[0, new_size)范围以外数据无效，如果下标index在区间外，vector[indext]是非法的。

  reserve只是保证vector的空间大小(capacity)最少达到它的参数所指定的大小n。在区间[0, n)范围内，如果下标是index，vector[index]这种访问有可能是合法的，也有可能是非法的，视具体情况而定。

  以下是两个接口的源代码：    

```
void resize(size_type new_size) {   resize(new_size, T()); } void resize(size_type new_size, const T& x) {  if (new_size < size())    erase(begin() + new_size, end()); // erase区间范围以外的数据，确保区间以外的数据无效  else   insert(end(), new_size - size(), x); // 填补区间范围内空缺的数据，确保区间内的数据有效 }   #include<iostream> #include<vector> using namespace std; int main() {     vector<int> a;     cout<<"initial capacity:"<<a.capacity()<<endl;     cout<<"initial size:"<<a.size()<<endl;      /*resize改变capacity和size*/     a.resize(20);     cout<<"resize capacity:"<<a.capacity()<<endl;     cout<<"resize size:"<<a.size()<<endl;       vector<int> b;     /*reserve改变capacity,不改变resize*/     b.reserve(100);     cout<<"reserve capacity:"<<b.capacity()<<endl;     cout<<"reserve size:"<<b.size()<<endl;  return 0; }  /*      运行结果：   initial capacity:0  initial size:0  resize capacity:20  resize size:20  reserve capacity:100  reserve size:0 */ 
```

  **注意：**如果n大于当前的vector的容量(是容量，并非vector的size)，将会引起自动内存分配。所以现有的pointer,references,iterators将会失效。而内存的重新配置会很耗时间。

#### 1.4.10 说说 STL 容器动态链接可能产生的问题？

**参考回答**

1. 可能产生 的问题

      容器是一种动态分配内存空间的一个变量集合类型变量。在一般的程序函数里，局部容器，参数传递容器，参数传递容器的引用，参数传递容器指针都是可以正常运行的，而在动态链接库函数内部使用容器也是没有问题的，但是给动态库函数传递容器的对象本身，则会出现内存堆栈破坏的问题。

2. 产生问题的原因 容器和动态链接库相互支持不够好，动态链接库函数中使用容器时，参数中只能传递容器的引用，并且要保证容器的大小不能超出初始大小，否则导致容器自动重新分配，就会出现内存堆栈破坏问题。

#### 1.4.11 说说 map 和 unordered_map 的区别？底层实现

**参考回答**

  map和unordered_map的区别在于他们的**实现基理不同**。

1. map实现机理

      map内部实现了一个**红黑树**（红黑树是非严格平衡的二叉搜索树，而AVL是严格平衡二叉搜索树），红黑树有自动排序的功能，因此map内部所有元素都是有序的，红黑树的每一个节点都代表着map的一个元素。因此，对于map进行的查找、删除、添加等一系列的操作都相当于是对红黑树进行的操作。map中的元素是按照二叉树（又名二叉查找树、二叉排序树）存储的，特点就是左子树上所有节点的键值都小于根节点的键值，右子树所有节点的键值都大于根节点的键值。使用中序遍历可将键值按照从小到大遍历出来。

2. unordered_map实现机理

    unordered_map内部实现了一个**哈希表**（也叫散列表），通过把关键码值映射到Hash表中一个位置来访问记录，查找时间复杂度可达O（1），其中在海量数据处理中有着广泛应用。因此，元素的排列顺序是无序的。

#### 1.4.12 说说 vector 和 list 的区别，分别适用于什么场景？

**参考回答**

  vector和list区别在于**底层实现机理不同**，因而特性和适用场景也有所不同。

  **vector：一维数组**

  特点：元素在内存连续存放，动态数组，在堆中分配内存，元素连续存放，有保留内存，如果减少大小后内存也不会释放。

  优点：和数组类似开辟一段连续的空间，并且支持随机访问，所以它的查找效率高其时间复杂度O(1)。

  缺点：由于开辟一段连续的空间，所以插入删除会需要对数据进行移动比较麻烦，时间复杂度O（n），另外当空间不足时还需要进行扩容。

  **list：双向链表**

  特点：元素在堆中存放，每个元素都是存放在一块内存中，它的内存空间可以是不连续的，通过指针来进行数据的访问。

  优点：底层实现是循环双链表，当对大量数据进行插入删除时，其时间复杂度O(1)。

  缺点：底层没有连续的空间，只能通过指针来访问，所以查找数据需要遍历其时间复杂度O（n），没有提供[]操作符的重载。

**应用场景**

  vector拥有一段连续的内存空间，因此支持随机访问，如果需要高效的随即访问，而不在乎插入和删除的效率，使用vector。

  list拥有一段不连续的内存空间，如果需要高效的插入和删除，而不关心随机访问，则应使用list。

#### 1.4.13 简述 vector 的实现原理

**参考回答**

  vector底层实现原理为**一维数组**（元素在空间连续存放）。

1. 新增元素

      Vector通过一个连续的数组存放元素，如果集合已满，在新增数据的时候，就要分配一块更大的内存，将原来的数据复制过来，释放之前的内存，在插入新增的元素。插入新的数据分在最后插入push_back和通过迭代器在任何位置插入，这里说一下通过迭代器插入，通过迭代器与第一个元素的距离知道要插入的位置，即int index=iter-begin()。这个元素后面的所有元素都向后移动一个位置，在空出来的位置上存入新增的元素。

    ```
    //新增元素  void insert(const_iterator iter,const T& t ) {    int index=iter-begin();  if (index<size_)  {   if (size_==capacity_)   {    int capa=calculateCapacity();    newCapacity(capa);   }   memmove(buf+index+1,buf+index,(size_-index)*sizeof(T));    buf[index]=t;   size_++;  }  }
    ```

2. 删除元素

      删除和新增差不多，也分两种，删除最后一个元素pop_back和通过迭代器删除任意一个元素erase(iter)。通过迭代器删除还是先找到要删除元素的位置，即int index=iter-begin();这个位置后面的每个元素都想前移动一个元素的位置。同时我们知道erase不释放内存只初始化成默认值。

      删除全部元素clear：只是循环调用了erase，所以删除全部元素的时候，不释放内存。内存是在析构函数中释放的。

    ```
    //删除元素  iterator erase(const_iterator iter) {     int index=iter-begin();      if (index<size_ && size_>0)     {         memmove(buf+index ,buf+index+1,(size_-index)*sizeof(T));          buf[--size_]=T();     }      return iterator(iter);  } 
    ```

3. 迭代器iteraotr

    迭代器iteraotr是STL的一个重要组成部分,通过iterator可以很方便的存储集合中的元素.STL为每个集合都写了一个迭代器, 迭代器其实是对一个指针的包装,实现一些常用的方法,如++,--,!=,==,*,->等, 通过这些方法可以找到当前元素或是别的元素. vector是STL集合中比较特殊的一个,因为vector中的每个元素都是连续的,所以在自己实现vector的时候可以用指针代替。

    ```
    //迭代器的实现 template<class _Category,class _Ty,class _Diff = ptrdiff_t,class _Pointer = _Ty *,class _Reference = _Ty&> struct iterator {         // base type for all iterator classes     typedef _Category iterator_category;     typedef _Ty value_type;     typedef _Diff difference_type;     typedef _Diff distance_type;    // retained     typedef _Pointer pointer;     typedef _Reference reference; };
    ```

4. vector实现源码

    ```
    #ifndef _CVECTOR_H_ #define _CVECTOR_H_  namespace cth {     class NoCopy     {     public:          inline NoCopy(){}         NoCopy(const NoCopy&);         NoCopy& operator=(const NoCopy&);      };      template<typename T>     class viterator:public std::iterator<std::forward_iterator_tag,T>     {     public:          viterator()         {             t=NULL;         }         viterator(T* t_)         {             t=t_;         }         viterator(const viterator& other)         {             t=other.t;         }         viterator& operator=(const viterator& other)         {             t=other.t;             return *this;         }          viterator& operator++()         {             t++;             return *this;         }          viterator operator++(int)         {             viterator iter=*this;             t++;             return iter;         }          viterator operator+(int count)         {             viterator iter=*this;             iter.t+=count;             return iter;         }          viterator& operator--()         {             t--;             return *this;         }          viterator operator--(int)         {             viterator iter=*this;             t--;             return iter;         }          viterator operator-(int count)         {             viterator iter=*this;             iter.t-=count;             return iter;         }          int operator-(const viterator& other)         {              return t-other.t;         }          int operator-(const viterator& other)const         {              return t-other.t;         }          T& operator*()         {             return *t;         }          const T& operator*() const         {             return *t;         }          T* operator->()         {             return t;         }         const T* operator->() const         {             return t;         }          inline bool operator!=(const viterator& other)         {             return t!=other.t;         }         inline bool operator!=(const viterator& other)const         {             return t!=other.t;         }          inline bool operator==(const viterator& other)         {             return t==other.t;         }         inline bool operator==(const viterator& other)const         {             return t==other.t;         }          inline bool operator<(const viterator& other)         {             return t<other.t;         }         inline bool operator<(const viterator& other)const         {             return t<other.t;         }          inline bool operator<=(const viterator& other)         {             return t<=other.t;         }         inline bool operator<=(const viterator& other)const         {             return t<=other.t;         }          inline bool operator>(const viterator& other)         {             return t>other.t;         }         inline bool operator>(const viterator& other)const         {             return t>other.t;         }          inline bool operator>=(const viterator& other)         {             return t>=other.t;         }          inline bool operator>=(const viterator& other)const         {             return t>=other.t;         }      private:          T* t;     };       template<typename T>     class cvector:public NoCopy     {     public:          typedef viterator<T> iterator;//viterator<T>就是对一个指针的包装，所以完全可以用T*代替viterator <T>         typedef const viterator<T> const_iterator;          //typedef T* iterator;         //typedef const T* const_iterator;         cvector()         {             initData(0);         }          cvector(int capa,const T& val=T())         {              initData(capa);             newCapacity(capacity_);             for (int i=0;i<size_;i++)                  buf[i]=val;          }          cvector(const_iterator first,const_iterator last)         {               initData(last-first);             newCapacity(capacity_);             iterator iter=iterator(first);              int index=0;             while(iter!=last)                 buf[index++]=*iter++;         }          ~cvector()         {             if (buf)             {                 delete[] buf;                 buf=NULL;             }             size_=capacity_=0;         }         void clear()         {             if (buf)                 erase(begin(),end());         }          void push_back(const T& t)         {             if (size_==capacity_)             {                 int capa=calculateCapacity();                 newCapacity(capa);             }             buf[size_++]=t;         }         void pop_back()         {              if (!empty())                 erase(end() - 1);          }          int insert(const_iterator iter,const T& t )         {               int index=iter-begin();             if (index<=size_)             {                 if (size_==capacity_)                 {                     int capa=calculateCapacity();                     newCapacity(capa);                 }                 memmove(buf+index+1,buf+index,(size_-index)*sizeof(T));                  buf[index]=t;                 size_++;             }              return index;         }         iterator erase(const_iterator iter)         {             int index=iter-begin();              if (index<size_ && size_>0)             {                 memmove(buf+index ,buf+index+1,(size_-index)*sizeof(T));                  buf[--size_]=T();             }              return iterator(iter);          }          iterator erase(const_iterator first,const_iterator last)         {              iterator first_=iterator(first);             iterator last_=iterator(last);              while(first_<=last_--)                  erase(first_);               return iterator(first_);         }          T& front()         {              assert(size_>0);             return buf[0];         }         T& back()         {              assert(size_>0);             return buf[size_-1];         }         T& at(int index)         {              assert(size_>0);             return buf[index];         }         T& operator[](int index)         {              assert(size_>0 && index>=0 && index<size_);             return buf[index];         }          bool empty() const         {             return size_==0;          }         int size() const         {             return size_;         }         int capacity() const         {             return capacity_;         }          iterator begin()         {               return iterator(&buf[0]);          }          iterator end()         {               return iterator(&buf[size_]);          }      private:          void newCapacity(int capa)         {              capacity_=capa;             T* newBuf=new T[capacity_];             if (buf)             {                 memcpy(newBuf,buf,size_*sizeof(T));                  delete [] buf;             }              buf=newBuf;         }          inline int calculateCapacity()         {             return capacity_*3/2+1 ;         }          inline void initData(int capa)         {             buf=NULL;             size_=capacity_=capa>0?capa:0;         }         int size_;          int capacity_ ;         T* buf;      };        struct Point     {         Point(int x_=0,int y_=0):x(x_),y(y_){}         int x,y;     };      bool operator<(const Point& p1,const Point& p2)     {         if(p1.x<p2.x)         {             return true;         }else if(p1.x>p2.x)         {             return false;         }         return p1.y<p2.y;     }      void cvectorTest()     {         cvector<Point> vect;         for (int i=0;i<10;i++)         {             Point p(i,i);              vect.push_back(p);         }          cvector<Point>::iterator iter=vect.begin();          while (iter!=vect.end())         {             cout<< "[" << iter->x << " " << iter->y <<"], ";             ++iter;         }         iter=vect.begin()+5;          vect.insert(iter,Point(55,55));          iter=vect.end()-3;          vect.insert(iter,Point(77,77));         cout<<endl<<endl<<"插入两个元素后："<<endl;         iter=vect.begin();          while (iter!=vect.end())         {             cout<< "[" << iter->x << " " << iter->y <<"], ";             ++iter;         }         std::sort(vect.begin(),vect.end());         cout<<endl<<endl<<"排序后："<<endl;         iter=vect.begin();          while (iter!=vect.end())         {             cout<< "[" << iter->x << " " << iter->y <<"], ";             ++iter;         }         vect.erase(vect.begin()+10);         vect.erase(vect.begin()+10);         cout<<endl<<endl<<"删除之前新增的两个元素"<<endl;         iter=vect.begin();          while (iter!=vect.end())         {             cout<< "[" << iter->x << " " << iter->y <<"], ";             ++iter;         }         vect.clear();         cout<<endl<<endl<<"执行clear之后"<<endl;         cout<<"size="<<vect.size()<<",capacity="<<vect.capacity();          cvector<Point> vect1;         for (int i=10;i<20;i++)         {             Point p(i,i);              vect1.push_back(p);         }         cout<<endl<<endl<<"从别的cvector复制数据:"<<endl;          cvector<Point> vect2(vect1.begin(),vect1.end());         vect2.pop_back();         vect2.pop_back();         for(int i=0;i<vect2.size();i++)         {             cout<<"["<<vect2[i].x<<","<<vect2[i].y<<"], ";         }          cout<<endl;      } }
    ```

    ```
    //实例代码级运行结果 struct Point     {         Point(int x_=0,int y_=0):x(x_),y(y_){}         int x,y;     };      bool operator<(const Point& p1,const Point& p2)     {         if(p1.x<p2.x)         {             return true;         }else if(p1.x>p2.x)         {             return false;         }         return p1.y<p2.y;     }      void cvectorTest()     {         cvector<Point> vect;         for (int i=0;i<10;i++)         {             Point p(i,i);              vect.push_back(p);         }          cvector<Point>::iterator iter=vect.begin();          while (iter!=vect.end())         {             cout<< "[" << iter->x << " " << iter->y <<"], ";             ++iter;         }         iter=vect.begin()+5;          vect.insert(iter,Point(55,55));          iter=vect.end()-3;          vect.insert(iter,Point(77,77));         cout<<endl<<endl<<"插入两个元素后："<<endl;         iter=vect.begin();          while (iter!=vect.end())         {             cout<< "[" << iter->x << " " << iter->y <<"], ";             ++iter;         }         std::sort(vect.begin(),vect.end());         cout<<endl<<endl<<"排序后："<<endl;         iter=vect.begin();          while (iter!=vect.end())         {             cout<< "[" << iter->x << " " << iter->y <<"], ";             ++iter;         }         vect.erase(vect.begin()+10);         vect.erase(vect.begin()+10);         cout<<endl<<endl<<"删除之前新增的两个元素"<<endl;         iter=vect.begin();          while (iter!=vect.end())         {             cout<< "[" << iter->x << " " << iter->y <<"], ";             ++iter;         }         vect.clear();         cout<<endl<<endl<<"执行clear之后"<<endl;         cout<<"size="<<vect.size()<<",capacity="<<vect.capacity();          cvector<Point> vect1;         for (int i=10;i<20;i++)         {             Point p(i,i);              vect1.push_back(p);         }         cout<<endl<<endl<<"从别的cvector复制数据:"<<endl;                   cvector<Point> vect2(vect1.begin(),vect1.end());         vect2.pop_back();         vect2.pop_back();         for(int i=0;i<vect2.size();i++)         {             cout<<"["<<vect2[i].x<<","<<vect2[i].y<<"], ";         }                   cout<<endl;      }
    ```

#### 1.4.14 简述 STL 中的 map 的实现原理

**参考回答**

​    map是关联式容器，它们的底层容器都是**红黑树**。map 的所有元素都是 pair，同时拥有实值（value）和键值（key）。pair 的第一元素被视为键值，第二元素被视为实值。所有元素都会根据元素的键值自动被排序。不允许键值重复。

1. map的特性如下

    （1）map以RBTree作为底层容器；

    （2）所有元素都是键+值存在；

    （3）不允许键重复；

    （4）所有元素是通过键进行自动排序的；

    （5）map的键是不能修改的，但是其键对应的值是可以修改的。

#### 1.4.15 C++ 的 vector 和 list中，如果删除末尾的元素，其指针和迭代器如何变化？若删除的是中间的元素呢？

**参考回答**

1. 迭代器和指针之间的区别

      **迭代器不是指针，是类模板，表现的像指针。**他只是模拟了指针的一些功能，重载了指针的一些操作符，-->、++、--等。迭代器封装了指针，是一个”可遍历STL（ Standard Template Library）容器内全部或部分元素”的对象，**本质**是封装了原生指针，是指针概念的一种提升，提供了比指针更高级的行为，相当于一种智能指针，他可以根据不同类型的数据结构来实现不同的++，--等操作。

      **迭代器返回的是对象引用而不是对象的值**，所以cout只能输出迭代器使用取值后的值而不能直接输出其自身。

2. vector和list特性

    **vector特性**  动态数组。元素在内存连续存放。随机存取任何元素都在常数时间完成。在尾端增删元素具有较大的性能（大部分情况下是常数时间）。

    **list特性**  双向链表。元素在内存不连续存放。在任何位置增删元素都能在常数时间完成。不支持随机存取。

3. vector增删元素

    对于vector而言，删除某个元素以后，该元素后边的每个元素的迭代器都会失效，后边每个元素都往前移动一位，erase返回下一个有效的迭代器。

4. list增删元素

    对于list而言，删除某个元素，只有“指向被删除元素”的那个迭代器失效，其它迭代器不受任何影响。

#### 1.4.16 请你来说一下 map 和 set 有什么区别，分别又是怎么实现的？

**参考回答**

1. set是一种关联式容器，其特性如下：

    （1）set以RBTree作为底层容器

    （2）所得元素的只有key没有value，value就是key

    （3）不允许出现键值重复

    （4）所有的元素都会被自动排序

    （5）不能通过迭代器来改变set的值，因为set的值就是键，set的迭代器是const的

2. map和set一样是关联式容器，其特性如下：

    （1）map以RBTree作为底层容器

    （2）所有元素都是键+值存在

    （3）不允许键重复

    （4）所有元素是通过键进行自动排序的

    （5）map的键是不能修改的，但是其键对应的值是可以修改的

    综上所述，map和set**底层实现**都是红黑树；map和set的**区别**在于map的值不作为键，键和值是分开的。

#### 1.4.17 说说 push_back 和 emplace_back 的区别

**参考回答**

  如果要将一个临时变量push到容器的末尾，push_back()需要先构造临时对象，再将这个对象拷贝到容器的末尾，而emplace_back()则直接在容器的末尾构造对象，这样就省去了拷贝的过程。

**答案解析**

  参考代码：

```
#include <iostream> #include <cstring> #include <vector> using namespace std;   class A { public:     A(int i){         str = to_string(i);         cout << "构造函数" << endl;      }     ~A(){}     A(const A& other): str(other.str){         cout << "拷贝构造" << endl;     }   public:     string str; };   int main() {     vector<A> vec;     vec.reserve(10);     for(int i=0;i<10;i++){         vec.push_back(A(i)); //调用了10次构造函数和10次拷贝构造函数,     // vec.emplace_back(i);  //调用了10次构造函数一次拷贝构造函数都没有调用过     } }
```

#### 1.4.18 STL 中 vector 与 list 具体是怎么实现的？常见操作的时间复杂度是多少？

**参考回答**

1. vector 一维数组（元素在内存连续存放）

      是动态数组，在堆中分配内存，元素连续存放，有保留内存，如果减少大小后，内存也不会释放；如果新增大小当前大小时才会重新分配内存。

      扩容方式： a. 倍放开辟三倍的内存

    ​            b. 旧的数据开辟到新的内存

    ​            c. 释放旧的内存

    ​            d. 指向新内存

2. list 双向链表（元素存放在堆中）

      元素存放在堆中，每个元素都是放在一块内存中，它的内存空间可以是不连续的，通过指针来进行数据的访问，这个特点，使得它的随机存取变得非常没有效率，因此它没有提供[ ]操作符的重载。但是由于链表的特点，它可以很有效的支持任意地方的删除和插入操作。

      特点：a. 随机访问不方便

    ​        b. 删除插入操作方便

3. 常见时间复杂度

    （1）vector插入、查找、删除时间复杂度分别为：O(n)、O(1)、O(n)；

    （2）list插入、查找、删除时间复杂度分别为：O(1)、O(n)、O(1)。



### 1.5 新特新

#### 1.5.1 说说 C++11 的新特性有哪些

**参考回答**

  C++新特性主要包括包含语法改进和标准库扩充两个方面，主要包括以下11点：

1. 语法的改进

    （1）统一的初始化方法

    （2）成员变量默认初始化

    （3）auto关键字  用于定义变量，编译器可以自动判断的类型（前提：定义一个变量时对其进行初始化）

    （4）decltype  求表达式的类型

    （5）智能指针 shared_ptr

    （6）空指针 nullptr（原来NULL）

    （7）基于范围的for循环

    （8）右值引用和move语义  让程序员有意识减少进行深拷贝操作

2. 标准库扩充（往STL里新加进一些模板类，比较好用）

    （9）无序容器（哈希表）  用法和功能同map一模一样，区别在于哈希表的效率更高

    （10）正则表达式  可以认为正则表达式实质上是一个字符串，该字符串描述了一种特定模式的字符串

    （11）Lambda表达式

**答案解析**

1. 统一的初始化方法

      C++98/03 可以使用初始化列表（initializer list）进行初始化：

    ```
    int i_arr[3] = { 1, 2, 3 }; long l_arr[] = { 1, 3, 2, 4 }; struct A {     int x;     int y; } a = { 1, 2 };
    ```

      **但是**这种初始化方式的**适用性非常狭窄**，只有上面提到的这两种数据类型可以使用初始化列表。在 C++11 中，初始化列表的适用性被大大增加了。它现在可以用于任何类型对象的初始化，实例如下：

    ```
    class Foo { public:     Foo(int) {} private:     Foo(const Foo &); }; int main(void) {     Foo a1(123);     Foo a2 = 123;  //error: 'Foo::Foo(const Foo &)' is private     Foo a3 = { 123 };     Foo a4 { 123 };     int a5 = { 3 };     int a6 { 3 };     return 0; }
    ```

      在上例中，a3、a4 使用了新的初始化方式来初始化对象，效果如同 a1 的直接初始化。a5、a6 则是基本数据类型的列表初始化方式。可以看到，它们的形式都是统一的。这里需要注意的是，a3 虽然使用了等于号，但它仍然是列表初始化，因此，私有的拷贝构造并不会影响到它。a4 和 a6 的写法，是 C++98/03 所不具备的。在 C++11 中，可以直接在变量名后面跟上初始化列表，来进行对象的初始化。

2. 成员变量默认初始化

    好处：构建一个类的对象不需要用构造函数初始化成员变量。

    ```
    //程序实例 #include<iostream> using namespace std; class B { public:  int m = 1234; //成员变量有一个初始值  int n; }; int main() {  B b;  cout << b.m << endl;  return 0; }
    ```

3. auto关键字  

      用于定义变量，编译器可以自动判断的类型（前提：定义一个变量时对其进行初始化）。

    ```
    //程序实例 #include <vector> using namespace std; int main(){     vector< vector<int> > v;     vector< vector<int> >::iterator i = v.begin();     return 0; }
    ```

      可以看出来，定义迭代器 i 的时候，类型书写比较冗长，容易出错。然而有了 auto 类型推导，我们大可不必这样，只写一个 auto 即可。

4. decltype  求表达式的类型

      decltype 是 [C++](http://c.biancheng.net/cplus/)11 新增的一个关键字，它和 auto 的功能一样，都用来在编译时期进行自动类型推导。

    (1)为什么要有decltype

      因为 auto 并不适用于所有的自动类型推导场景，在某些特殊情况下 auto 用起来非常不方便，甚至压根无法使用，所以 decltype 关键字也被引入到 C++11 中。

      auto 和 decltype 关键字都可以自动推导出变量的类型，但它们的用法是有区别的：

    ```
    auto varname = value; decltype(exp) varname = value;
    ```

      其中，varname 表示变量名，value 表示赋给变量的值，exp 表示一个表达式。

      auto 根据"="右边的初始值 value 推导出变量的类型，而 decltype 根据 exp 表达式推导出变量的类型，跟"="右边的 value 没有关系。

      另外，auto 要求变量必须初始化，而 decltype 不要求。这很容易理解，auto 是根据变量的初始值来推导出变量类型的，如果不初始化，变量的类型也就无法推导了。decltype 可以写成下面的形式：

    ```
    decltype(exp) varname;
    ```

    (2)代码示例

    ```
    // decltype 用法举例 nt a = 0; decltype(a) b = 1;  //b 被推导成了 int decltype(10.8) x = 5.5;  //x 被推导成了 double decltype(x + 100) y;  //y 被推导成了 double
    ```

5. 智能指针 shared_ptr

      和 unique_ptr、weak_ptr 不同之处在于，多个 shared_ptr 智能指针可以共同使用同一块堆内存。并且，由于该类型智能指针在实现上采用的是引用计数机制，即便有一个 shared_ptr 指针放弃了堆内存的“使用权”（引用计数减 1），也不会影响其他指向同一堆内存的 shared_ptr 指针（只有引用计数为 0 时，堆内存才会被自动释放）。

    ```
    #include <iostream> #include <memory> using namespace std; int main() {     //构建 2 个智能指针     std::shared_ptr<int> p1(new int(10));     std::shared_ptr<int> p2(p1);     //输出 p2 指向的数据     cout << *p2 << endl;     p1.reset();//引用计数减 1,p1为空指针     if (p1) {         cout << "p1 不为空" << endl;     }     else {         cout << "p1 为空" << endl;     }     //以上操作，并不会影响 p2     cout << *p2 << endl;     //判断当前和 p2 同指向的智能指针有多少个     cout << p2.use_count() << endl;     return 0; }  /*      程序运行结果：          10  p1 为空  10  1  */          
    ```

6. 空指针 nullptr（原来NULL）

      nullptr 是 nullptr_t 类型的右值常量，专用于初始化空类型指针。nullptr_t 是 C++11 新增加的数据类型，可称为“指针空值类型”。也就是说，nullpter 仅是该类型的一个实例对象（已经定义好，可以直接使用），如果需要我们完全定义出多个同 nullptr 完全一样的实例对象。值得一提的是，nullptr 可以被隐式转换成任意的指针类型。例如：

    ```
    int * a1 = nullptr;
    char * a2 = nullptr;
    double * a3 = nullptr;
    ```

      显然，不同类型的指针变量都可以使用 nullptr 来初始化，编译器分别将 nullptr 隐式转换成 int*、char* 以及 double* 指针类型。另外，通过将指针初始化为 nullptr，可以很好地解决 NULL 遗留的问题，比如：

    ```
    #include <iostream>
    using namespace std;
    void isnull(void *c){
        cout << "void*c" << endl;
    }
    void isnull(int n){
        cout << "int n" << endl;
    }
    int main() {
        isnull(NULL);
        isnull(nullptr);
        return 0;
    }
    
    /*    
        程序运行结果：        
        int n
        void*c
    */          
    ```

7. 基于范围的for循环

      如果要用 for 循环语句遍历一个数组或者容器，只能套用如下结构：

    ```
    for(表达式 1; 表达式 2; 表达式 3){
        //循环体
    }
    ```

    ```
    //程序实例
    #include <iostream>
    #include <vector>
    #include <string.h>
    using namespace std;
    int main() {
        char arc[] = "www.123.com";
        int i;
        //for循环遍历普通数组
        for (i = 0; i < strlen(arc); i++) {
            cout << arc[i];
        }
        cout << endl;
        vector<char>myvector(arc,arc+3);
        vector<char>::iterator iter;
        //for循环遍历 vector 容器
        for (iter = myvector.begin(); iter != myvector.end(); ++iter) {
            cout << *iter;
        }
        return 0;
    }
    /*    
        程序运行结果：        
        www.123.com
        www
    */          
    ```

8. 右值引用和move语义  

    1. 右值引用

          C++98/03 标准中就有引用，使用 "&" 表示。但此种引用方式有一个缺陷，即正常情况下只能操作 C++ 中的左值，无法对右值添加引用。举个例子：

        ```
        int num = 10;
        int &b = num; //正确
        int &c = 10; //错误
        ```

          如上所示，编译器允许我们为 num 左值建立一个引用，但不可以为 10 这个右值建立引用。因此，C++98/03 标准中的引用又称为左值引用。

        注意，虽然 C++98/03 标准不支持为右值建立非常量左值引用，但允许使用常量左值引用操作右值。也就是说，常量左值引用既可以操作左值，也可以操作右值，例如：

        ```
        int num = 10;
        const int &b = num;
        const int &c = 10;
        ```

          我们知道，右值往往是没有名称的，因此要使用它只能借助引用的方式。这就产生一个问题，实际开发中我们可能需要对右值进行修改（实现移动语义时就需要），显然左值引用的方式是行不通的。

          为此，C++11 标准新引入了另一种引用方式，称为右值引用，用 "&&" 表示。

          需要注意的，和声明左值引用一样，右值引用也必须立即进行初始化操作，且只能使用右值进行初始化，比如：

        ```
        int num = 10;
        //int && a = num;  //右值引用不能初始化为左值
        int && a = 10;
        ```

          和常量左值引用不同的是，右值引用还可以对右值进行修改。例如：

        ```
        int && a = 10;
        a = 100;
        cout << a << endl;
        /*    程序运行结果：        
                100    
        */          
        ```

          另外值得一提的是，C++ 语法上是支持定义常量右值引用的，例如：

        ```
        const int&& a = 10;//编译器不会报错
        ```

          但这种定义出来的右值引用并无实际用处。一方面，右值引用主要用于移动语义和完美转发，其中前者需要有修改右值的权限；其次，常量右值引用的作用就是引用一个不可修改的右值，这项工作完全可以交给常量左值引用完成。

    2. move语义

          move 本意为 "移动"，但该函数并不能移动任何数据，它的功能很简单，就是将某个左值强制转化为右值。基于 move() 函数特殊的功能，其常用于实现移动语义。move() 函数的用法也很简单，其语法格式如下：

        ```
        move( arg ) //其中，arg 表示指定的左值对象。该函数会返回 arg 对象的右值形式。
        ```

        ```
        //程序实例
        #include <iostream>
        using namespace std;
        class first {
        public:
            first() :num(new int(0)) {
                cout << "construct!" << endl;
            }
            //移动构造函数
            first(first &&d) :num(d.num) {
                d.num = NULL;
                cout << "first move construct!" << endl;
            }
        public:    //这里应该是 private，使用 public 是为了更方便说明问题
            int *num;
        };
        class second {
        public:
            second() :fir() {}
            //用 first 类的移动构造函数初始化 fir
            second(second && sec) :fir(move(sec.fir)) {
                cout << "second move construct" << endl;
            }
        public:    //这里也应该是 private，使用 public 是为了更方便说明问题
            first fir;
        };
        int main() {
            second oth;
            second oth2 = move(oth);
            //cout << *oth.fir.num << endl;   //程序报运行时错误
            return 0;
        }
        
        /*    
            程序运行结果：
              construct!
            first move construct!
            second move construct
        */            
        ```

9. 无序容器（哈希表）  

    用法和功能同map一模一样，区别在于哈希表的效率更高。

    (1) 无序容器具有以下 2 个特点：

      a. 无序容器内部存储的键值对是无序的，各键值对的存储位置取决于该键值对中的键，

      b. 和关联式容器相比，无序容器擅长通过指定键查找对应的值（平均时间复杂度为 O(1)）；但对于使用迭代器遍历容器中存储的元素，无序容器的执行效率则不如关联式容器。

    (2) 和关联式容器一样，无序容器只是一类容器的统称，其包含有 4 个具体容器，分别为 unordered_map、unordered_multimap、unordered_set 以及 unordered_multiset。功能如下表：

    | 无序容器           | 功能                                                         |
    | ------------------ | ------------------------------------------------------------ |
    | unordered_map      | 存储键值对 <key, value> 类型的元素，其中各个键值对键的值不允许重复，且该容器中存储的键值对是无序的。 |
    | unordered_multimap | 和 unordered_map 唯一的区别在于，该容器允许存储多个键相同的键值对。 |
    | unordered_set      | 不再以键值对的形式存储数据，而是直接存储数据元素本身（当然也可以理解为，该容器存储的全部都是键 key 和值 value 相等的键值对，正因为它们相等，因此只存储 value 即可）。另外，该容器存储的元素不能重复，且容器内部存储的元素也是无序的。 |
    | unordered_multiset | 和 unordered_set 唯一的区别在于，该容器允许存储值相同的元素。 |

    (3) 程序实例（以 unordered_map 容器为例）

    ```
    #include <iostream>
    #include <string>
    #include <unordered_map>
    using namespace std;
    int main()
    {
        //创建并初始化一个 unordered_map 容器，其存储的 <string,string> 类型的键值对
        std::unordered_map<std::string, std::string> my_uMap{
            {"教程1","www.123.com"},
            {"教程2","www.234.com"},
            {"教程3","www.345.com"} };
        //查找指定键对应的值，效率比关联式容器高
        string str = my_uMap.at("C语言教程");
        cout << "str = " << str << endl;
        //使用迭代器遍历哈希容器，效率不如关联式容器
        for (auto iter = my_uMap.begin(); iter != my_uMap.end(); ++iter)
        {
            //pair 类型键值对分为 2 部分
            cout << iter->first << " " << iter->second << endl;
        }
        return 0;
    }
    
    /*    
        程序运行结果：
          教程1 www.123.com
          教程2 www.234.com
          教程3 www.345.com
    */            
    ```

10. 正则表达式  

    可以认为正则表达式实质上是一个字符串，该字符串描述了一种特定模式的字符串。常用符号的意义如下：

    | 符号  | 意义                           |
    | ----- | ------------------------------ |
    | ^     | 匹配行的开头                   |
    | $     | 匹配行的结尾                   |
    | .     | 匹配任意单个字符               |
    | […]   | 匹配[]中的任意一个字符         |
    | (…)   | 设定分组                       |
    | \     | 转义字符                       |
    | \d    | 匹配数字[0-9]                  |
    | \D    | \d 取反                        |
    | \w    | 匹配字母[a-z]，数字，下划线    |
    | \W    | \w 取反                        |
    | \s    | 匹配空格                       |
    | \S    | \s 取反                        |
    | +     | 前面的元素重复1次或多次        |
    | *     | 前面的元素重复任意次           |
    | ?     | 前面的元素重复0次或1次         |
    | {n}   | 前面的元素重复n次              |
    | {n,}  | 前面的元素重复至少n次          |
    | {n,m} | 前面的元素重复至少n次，至多m次 |
    | \|    | 逻辑或                         |

11. Lambda匿名函数

    所谓匿名函数，简单地理解就是没有名称的函数，又常被称为 lambda 函数或者 lambda 表达式。

    （1）定义

      lambda 匿名函数很简单，可以套用如下的语法格式：

    ​    [外部变量访问方式说明符] (参数) mutable noexcept/throw() -> 返回值类型     {      函数体;     };

    其中各部分的含义分别为：

    a. [外部变量方位方式说明符]   [ ] 方括号用于向编译器表明当前是一个 lambda 表达式，其不能被省略。在方括号内部，可以注明当前 lambda 函数的函数体中可以使用哪些“外部变量”。

      所谓外部变量，指的是和当前 lambda 表达式位于同一作用域内的所有局部变量。

    b. (参数)   和普通函数的定义一样，lambda 匿名函数也可以接收外部传递的多个参数。和普通函数不同的是，如果不需要传递参数，可以连同 () 小括号一起省略；

    c. mutable   此关键字可以省略，如果使用则之前的 () 小括号将不能省略（参数个数可以为 0）。默认情况下，对于以值传递方式引入的外部变量，不允许在 lambda 表达式内部修改它们的值（可以理解为这部分变量都是 const 常量）。而如果想修改它们，就必须使用 mutable 关键字。

      **注意:**对于以值传递方式引入的外部变量，lambda 表达式修改的是拷贝的那一份，并不会修改真正的外部变量；

    d. noexcept/throw()   可以省略，如果使用，在之前的 () 小括号将不能省略（参数个数可以为 0）。默认情况下，lambda 函数的函数体中可以抛出任何类型的异常。而标注 noexcept 关键字，则表示函数体内不会抛出任何异常；使用 throw() 可以指定 lambda 函数内部可以抛出的异常类型。

    e. -> 返回值类型   指明 lambda 匿名函数的返回值类型。值得一提的是，如果 lambda 函数体内只有一个 return 语句，或者该函数返回 void，则编译器可以自行推断出返回值类型，此情况下可以直接省略"-> 返回值类型"。

    f. 函数体   和普通函数一样，lambda 匿名函数包含的内部代码都放置在函数体中。该函数体内除了可以使用指定传递进来的参数之外，还可以使用指定的外部变量以及全局范围内的所有全局变量。

    （2）程序实例

```
#include <iostream>
#include <algorithm>
using namespace std;
int main()
{
    int num[4] = {4, 2, 3, 1};
    //对 a 数组中的元素进行排序
    sort(num, num+4, [=](int x, int y) -> bool{ return x < y; } );
    for(int n : num){
        cout << n << " ";
    }
    return 0;
}

/*    程序运行结果：
          1 2 3 4
*/            
```

#### 1.5.2 说说 C++ 中智能指针和指针的区别是什么？

**参考回答**

1. 智能指针

      如果在程序中使用new从堆（自由存储区）分配内存，等到不需要时，应使用delete将其释放。C++引用了智能指针auto_ptr，以帮助自动完成这个过程。随后的编程体验（尤其是使用STL）表明，需要有更精致的机制。基于程序员的编程体验和BOOST库提供的解决方案，C++11摒弃了auto_ptr，并新增了三种智能指针：unique_ptr、shared_ptr和weak_ptr。所有新增的智能指针都能与STL容器和移动语义协同工作。

2. 指针

      C 语言规定所有变量在使用前必须先定义，指定其类型，并按此分配内存单元。指针变量不同于整型变量和其他类型的变量，它是专门用来存放地址的，所以必须将它定义为“指针类型”。

3. 智能指针和普通指针的区别

  **智能指针和普通指针的区别**在于智能指针实际上是对普通指针加了一层封装机制，区别是它负责自动释放所指的对象，这样的一层封装机制的目的是为了使得智能指针可以方便的管理一个对象的生命期。

**答案解析**

  无

#### 1.5.3 说说 C++中的智能指针有哪些？分别解决的问题以及区别？

**参考回答**

1. C++中的智能指针有4种，分别为：**shared_ptr、unique_ptr、weak_ptr、auto_ptr**，其中auto_ptr被C++11弃用。

2. 使用智能指针的原因

      申请的空间（即new出来的空间），在使用结束时，需要delete掉，否则会形成内存碎片。在程序运行期间，new出来的对象，在析构函数中delete掉，但是这种方法不能解决所有问题，因为有时候new发生在某个全局函数里面，该方法会给程序员造成精神负担。**此时，智能指针就派上了用场。**使用智能指针可以很大程度上避免这个问题，因为智能指针就是一个类，当超出了类的作用域时，类会自动调用析构函数，析构函数会自动释放资源。所以，智能指针的作用原理就是在函数结束时自动释放内存空间，避免了手动释放内存空间。

3. 四种指针分别解决的问题以及各自特性如下：

    （1）auto_ptr（C++98的方案，C++11已经弃用）

      采用所有权模式。

    ```
    auto_ptr<string> p1(new string("I reigned loney as a cloud."));
    auto_ptr<string> p2;
    p2=p1; //auto_ptr不会报错
    ```

      此时不会报错，p2剥夺了p1的所有权，但是当程序运行时访问p1将会报错。所以auto_ptr的缺点是：存在潜在的内存崩溃问题。

    （2）unique_ptr（替换auto_ptr）

      unique_ptr实现独占式拥有或严格拥有概念，保证同一时间内只有一个智能指针可以指向该对象。它对于避免资源泄露，例如，以new创建对象后因为发生异常而忘记调用delete时的情形特别有用。

      采用所有权模式，和上面例子一样。

    ```
    auto_ptr<string> p3(new string("I reigned loney as a cloud."));
    auto_ptr<string> p4;
    p4=p3; //此时不会报错
    ```

      编译器认为P4=P3非法，避免了p3不再指向有效数据的问题。因此，unique_ptr比auto_ptr更安全。 另外unique_ptr还有更聪明的地方：当程序试图将一个 unique_ptr 赋值给另一个时，如果源 unique_ptr 是个临时右值，编译器允许这么做；如果源 unique_ptr 将存在一段时间，编译器将禁止这么做，比如：

    ```
    unique_ptr<string> pu1(new string ("hello world"));
    unique_ptr<string> pu2;
    pu2 = pu1;                                      // #1 not allowed
    unique_ptr<string> pu3;
    pu3 = unique_ptr<string>(new string ("You"));   // #2 allowed
    ```

      其中#1留下悬挂的unique_ptr(pu1)，这可能导致危害。而#2不会留下悬挂的unique_ptr，因为它调用 unique_ptr 的构造函数，该构造函数创建的临时对象在其所有权让给 pu3 后就会被销毁。这种随情况而已的行为表明，unique_ptr 优于允许两种赋值的auto_ptr 。

      **注意：**如果确实想执行类似与#1的操作，要安全的重用这种指针，可给它赋新值。C++有一个标准库函数std::move()，让你能够将一个unique_ptr赋给另一个。例如：

    ```
    unique_ptr<string> ps1, ps2;
    ps1 = demo("hello");
    ps2 = move(ps1);
    ps1 = demo("alexia");
    cout << *ps2 << *ps1 << endl;
    ```

    （3）shared_ptr（非常好使）

      shared_ptr实现共享式拥有概念。多个智能指针可以指向相同对象，该对象和其相关资源会在“最后一个引用被销毁”时候释放。从名字share就可以看出了资源可以被多个指针共享，它使用计数机制来表明资源被几个指针共享。可以通过成员函数use_count()来查看资源的所有者个数。除了可以通过new来构造，还可以通过传入auto_ptr, unique_ptr,weak_ptr来构造。当我们调用release()时，当前指针会释放资源所有权，计数减一。当计数等于0时，资源会被释放。

      shared_ptr 是为了解决 auto_ptr 在对象所有权上的局限性(auto_ptr 是独占的), 在使用引用计数的机制上提供了可以共享所有权的智能指针。

    **成员函数：**

    **use_count**  返回引用计数的个数

    **unique**  返回是否是独占所有权( use_count 为 1)

    **swap**  交换两个 shared_ptr 对象(即交换所拥有的对象)

    **reset**  放弃内部对象的所有权或拥有对象的变更, 会引起原有对象的引用计数的减少

    **get**  返回内部对象(指针), 由于已经重载了()方法, 因此和直接使用对象是一样的.如 shared_ptr<int> sp(new int(1)); sp 与 sp.get()是等价的

    （4）weak_ptr

      weak_ptr 是一种不控制对象生命周期的智能指针, 它指向一个 shared_ptr 管理的对象。进行该对象的内存管理的是那个强引用的 shared_ptr。weak_ptr只是提供了对管理对象的一个访问手段。weak_ptr 设计的目的是为配合 shared_ptr 而引入的一种智能指针来协助 shared_ptr 工作，它只可以从一个 shared_ptr 或另一个 weak_ptr 对象构造, 它的构造和析构不会引起引用记数的增加或减少。weak_ptr是用来解决shared_ptr相互引用时的死锁问题，如果说两个shared_ptr相互引用，那么这两个指针的引用计数永远不可能下降为0,资源永远不会释放。它是对对象的一种弱引用，不会增加对象的引用计数，和shared_ptr之间可以相互转化，shared_ptr可以直接赋值给它，它可以通过调用lock函数来获得shared_ptr。

    ```
    class B;
    class A
    {
    public:
        shared_ptr<B> pb_;
        ~A()
    {
        cout<<"A delete\n";
    }
    };
    class B
    {
    public:
        shared_ptr<A> pa_;
        ~B()
    {
        cout<<"B delete\n";
    }
    };
    void fun()
    {
        shared_ptr<B> pb(new B());
        shared_ptr<A> pa(new A());
        pb->pa_ = pa;
        pa->pb_ = pb;
        cout<<pb.use_count()<<endl;
        cout<<pa.use_count()<<endl;
    }
    int main()
    {
        fun();
        return 0;
    }
    ```

      可以看到fun函数中pa ，pb之间互相引用，两个资源的引用计数为2，当要跳出函数时，智能指针pa，pb析构时两个资源引用计数会减一，但是两者引用计数还是为1，导致跳出函数时资源没有被释放（A B的析构函数没有被调用），如果把其中一个改为weak_ptr就可以了，我们把类A里面的shared_ptr pb_; 改为weak_ptr pb; 运行结果如下，这样的话，资源B的引用开始就只有1，当pb析构时，B的计数变为0，B得到释放，B释放的同时也会使A的计数减一，同时pa析构时使A的计数减一，那么A的计数为0，A得到释放。

      **注意**：我们不能通过weak_ptr直接访问对象的方法，比如B对象中有一个方法print(),我们不能这样访问，pa->pb*->print(); 英文pb*是一个weak_ptr，应该先把它转化为shared_ptr，如：shared_ptr p = pa->pb_.lock(); p->print();   

**答案解析**

  无



#### 1.5.4 简述 C++ 右值引用与转移语义

**参考回答**

1. 右值引用

    一般来说，不能取地址的表达式，就是右值引用，能取地址的，就是左值。

```
class A { }; A & r = A(); //error,A()是无名变量，是右值 A && r = A(); //ok,r是右值引用
```

1. 转移语义

      move 本意为 "移动"，但该函数并不能移动任何数据，它的功能很简单，就是将某个左值强制转化为右值。基于 move() 函数特殊的功能，其常用于实现移动语义。

**答案解析**

1. 右值引用

  C++98/03 标准中就有引用，使用 "&" 表示。但此种引用方式有一个缺陷，即正常情况下只能操作 C++ 中的左值，无法对右值添加引用。举个例子：

```
int num = 10; int &b = num; //正确 int &c = 10; //错误
```

  如上所示，编译器允许我们为 num 左值建立一个引用，但不可以为 10 这个右值建立引用。因此，C++98/03 标准中的引用又称为左值引用。

  **注意：**虽然 C++98/03 标准不支持为右值建立非常量左值引用，但允许使用常量左值引用操作右值。也就是说，常量左值引用既可以操作左值，也可以操作右值，例如：

```
int num = 10; const int &b = num; const int &c = 10;
```

  我们知道，右值往往是没有名称的，因此要使用它只能借助引用的方式。这就产生一个问题，实际开发中我们可能需要对右值进行修改（实现移动语义时就需要），显然左值引用的方式是行不通的。

  为此，C++11 标准新引入了另一种引用方式，称为右值引用，用 "&&" 表示。

  **注意：**和声明左值引用一样，右值引用也必须立即进行初始化操作，且只能使用右值进行初始化，比如：

```
int num = 10; //int && a = num;  //右值引用不能初始化为左值 int && a = 10;
```

  和常量左值引用不同的是，右值引用还可以对右值进行修改。例如：

```
int && a = 10; a = 100; cout << a << endl; /*    程序运行结果：           100  */          
```

  另外值得一提的是，C++ 语法上是支持定义常量右值引用的，例如：

```
const int&& a = 10;//编译器不会报错
```

  但这种定义出来的右值引用并无实际用处。一方面，右值引用主要用于移动语义和完美转发，其中前者需要有修改右值的权限；其次，常量右值引用的作用就是引用一个不可修改的右值，这项工作完全可以交给常量左值引用完成。

1. move语义

```
//程序实例 #include <iostream> using namespace std; class first { public:     first() :num(new int(0)) {         cout << "construct!" << endl;     }     //移动构造函数     first(first &&d) :num(d.num) {         d.num = NULL;         cout << "first move construct!" << endl;     } public:    //这里应该是 private，使用 public 是为了更方便说明问题     int *num; }; class second { public:     second() :fir() {}     //用 first 类的移动构造函数初始化 fir     second(second && sec) :fir(move(sec.fir)) {         cout << "second move construct" << endl;     } public:    //这里也应该是 private，使用 public 是为了更方便说明问题     first fir; }; int main() {     second oth;     second oth2 = move(oth);     //cout << *oth.fir.num << endl;   //程序报运行时错误     return 0; }  /*      程序运行结果：   construct!  first move construct!  second move construct */   
```

#### 1.5.5 简述 C++ 中智能指针的特点

**参考回答**

1. C++中的智能指针有4种，分别为：**shared_ptr、unique_ptr、weak_ptr、auto_ptr**，其中auto_ptr被C++11弃用。  

2. **为什么要使用智能指针**：智能指针的作用是管理一个指针，因为存在申请的空间在函数结束时忘记释放，造成内存泄漏的情况。使用智能指针可以很大程度上避免这个问题，因为智能指针就是一个类，当超出了类的作用域时，类会自动调用析构函数，自动释放资源。

3. 四种指针各自特性

    **（1）auto_ptr**

      auto指针存在的问题是，两个智能指针同时指向一块内存，就会两次释放同一块资源，自然报错。

    **（2）unique_ptr**

      unique指针规定一个智能指针独占一块内存资源。当两个智能指针同时指向一块内存，编译报错。

      **实现原理：**将拷贝构造函数和赋值拷贝构造函数申明为private或delete。不允许拷贝构造函数和赋值操作符，但是支持移动构造函数，通过std:move把一个对象指针变成右值之后可以移动给另一个unique_ptr

    **（3）shared_ptr**

      共享指针可以实现多个智能指针指向相同对象，该对象和其相关资源会在引用为0时被销毁释放。

      **实现原理：**有一个引用计数的指针类型变量，专门用于引用计数，使用拷贝构造函数和赋值拷贝构造函数时，引用计数加1，当引用计数为0时，释放资源。

**注意：**weak_ptr、shared_ptr存在一个问题，当两个shared_ptr指针相互引用时，那么这两个指针的引用计数不会下降为0，资源得不到释放。因此引入weak_ptr，weak_ptr是弱引用，weak_ptr的构造和析构不会引起引用计数的增加或减少。

#### 1.5.6 weak_ptr 能不能知道对象计数为 0，为什么？

**参考回答**

  不能。

  weak_ptr是一种不控制对象生命周期的智能指针，它指向一个shared_ptr管理的对象。进行该对象管理的是那个引用的shared_ptr。weak_ptr只是提供了对管理 对象的一个访问手段。weak_ptr设计的目的只是为了配合shared_ptr而引入的一种智能指针，配合shared_ptr工作，它只可以从一个shared_ptr或者另一个weak_ptr对象构造，**它的构造和析构不会引起计数的增加或减少**。

#### 1.5.7 weak_ptr 如何解决 shared_ptr 的循环引用问题？

**参考回答**

  为了解决循环引用导致的内存泄漏，引入了弱指针weak_ptr，weak_ptr的构造函数不会修改引用计数的值，从而不会对对象的内存进行管理，其类似一个普通指针，但是不会指向引用计数的共享内存，但是可以检测到所管理的对象是否已经被释放，从而避免非法访问。

#### 1.5.8 share_ptr 怎么知道跟它共享对象的指针释放了

**参考回答**

  多个shared_ptr对象可以同时托管一个指针，系统会维护一个托管计数。当无shared_ptr托管该指针时，delete该指针。

#### 1.5.9 说说智能指针及其实现，shared_ptr 线程安全性，原理

**参考回答**

  \1. C++里面的**四个智能指针**: **auto_ptr, shared_ptr, weak_ptr, unique_ptr** 其中后三个是c++11支持，并且第一个已经被11弃用。

1. 为什么要使用智能指针

      智能指针的作用是管理一个指针，因为存在以下这种情况：申请的空间在函数结束时忘记释放，造成内存泄漏。使用智能指针可以很大程度上的避免这个问题，因为智能指针就是一个类，当超出了类的作用域是，类会自动调用析构函数，析构函数会自动释放资源。所以智能指针的作用原理就是在函数结束时自动释放内存空间，不需要手动释放内存空间。

2. 四种指针分别解决的问题以及各自特性如下：

    （1）auto_ptr（C++98的方案，C++11已经弃用）

    ```
    //程序实例 auto_ptr<string> p1(new string("I reigned loney as a cloud.")); auto_ptr<string> p2; p2=p1; //auto_ptr不会报错
    ```

      **采用所有权模式。**此时不会报错，p2剥夺了p1的所有权，但是当程序运行时访问p1将会报错。所以auto_ptr的**缺点**是：存在潜在的内存崩溃问题。

    （2）unique_ptr（替换auto_ptr）

      unique_ptr**实现独占式拥有或严格拥有概念**，保证同一时间内只有一个智能指针可以指向该对象。**它对于避免资源泄露，例如，以new创建对象后因为发生异常而忘记调用delete时的情形特别有用。**

    ```
    //程序实例
    auto_ptr<string> p3(new string("I reigned loney as a cloud."));
    auto_ptr<string> p4;
    p4=p3; //此时不会报错
    ```

      采用所有权模式，和上面例子一样。编译器认为P4=P3非法，避免了p3不再指向有效数据的问题。因此，unique_ptr比auto_ptr更安全。 另外unique_ptr还有更聪明的地方：当程序试图将一个 unique_ptr 赋值给另一个时，如果源 unique_ptr 是个临时右值，编译器允许这么做；如果源 unique_ptr 将存在一段时间，编译器将禁止这么做，比如以下代码：

    ```
    //程序实例
    unique_ptr<string> pu1(new string ("hello world"));
    unique_ptr<string> pu2;
    pu2 = pu1;                                      // #1 not allowed
    unique_ptr<string> pu3;
    pu3 = unique_ptr<string>(new string ("You"));   // #2 allowed
    ```

      其中#1留下悬挂的unique_ptr(pu1)，这可能导致危害。而#2不会留下悬挂的unique_ptr，因为它调用 unique_ptr 的构造函数，该构造函数创建的临时对象在其所有权让给 pu3 后就会被销毁。这种随情况而已的行为表明，unique_ptr 优于允许两种赋值的auto_ptr 。 **注意：**如果确实想执行类似与#1的操作，要安全的重用这种指针，可给它赋新值。C++有一个标准库函数std::move()，让你能够将一个unique_ptr赋给另一个。例如：

    ```
    //程序实例
    unique_ptr<string> ps1, ps2;
    ps1 = demo("hello");
    ps2 = move(ps1);
    ps1 = demo("alexia");
    cout << *ps2 << *ps1 << endl;
    ```

（3）shared_ptr（非常好使）

  **shared_ptr实现共享式拥有概念。**多个智能指针可以指向相同对象，该对象和其相关资源会在“最后一个引用被销毁”时候释放。从名字share就可以看出了**资源可以被多个指针共享，它使用计数机制来表明资源被几个指针共享。可以通过成员函数use_count()来查看资源的所有者个数。**除了可以通过new来构造，还可以通过传入auto_ptr, unique_ptr,weak_ptr来构造。当我们调用release()时，当前指针会释放资源所有权，计数减一。当计数等于0时，资源会被释放。

  shared_ptr 是为了解决 auto_ptr 在对象所有权上的局限性(auto_ptr 是独占的), 在使用引用计数的机制上提供了可以共享所有权的智能指针。其成员函数如下：

​    **use_count**  返回引用计数的个数

​    **unique**  返回是否是独占所有权( use_count 为 1)

​    **swap**  交换两个 shared_ptr 对象(即交换所拥有的对象)

​    **reset**  放弃内部对象的所有权或拥有对象的变更, 会引起原有对象的引用计数的减少

​    **get**  返回内部对象(指针), 由于已经重载了()方法, 因此和直接使用对象是一样的.如 shared_ptr<int> sp(new int(1)); sp 与 sp.get()是等价的

（4）weak_ptr

  weak_ptr 是一种不控制对象生命周期的智能指针, 它指向一个 shared_ptr 管理的对象。进行该对象的内存管理的是那个强引用的 shared_ptr。weak_ptr只是提供了对管理对象的一个访问手段。**weak_ptr 设计的目的是为配合 shared_ptr 而引入的一种智能指针来协助 shared_ptr 工作，它只可以从一个 shared_ptr 或另一个 weak_ptr 对象构造, 它的构造和析构不会引起引用记数的增加或减少。  \****weak_ptr是用来解决shared_ptr相互引用时的死锁问题**，如果说两个shared_ptr相互引用，那么这两个指针的引用计数永远不可能下降为0，资源永远不会释放。它是对对象的一种弱引用，不会增加对象的引用计数，和shared_ptr之间可以相互转化，shared_ptr可以直接赋值给它，它可以通过调用lock函数来获得shared_ptr。

```
//程序实例
    class B;
    class A
    {
    public:
        shared_ptr<B> pb_;
        ~A()
    {
        cout<<"A delete\n";
    }
    };
    class B
    {
    public:
        shared_ptr<A> pa_;
        ~B()
    {
        cout<<"B delete\n";
    }
    };
    void fun()
    {
        shared_ptr<B> pb(new B());
        shared_ptr<A> pa(new A());
        pb->pa_ = pa;
        pa->pb_ = pb;
        cout<<pb.use_count()<<endl;
        cout<<pa.use_count()<<endl;
    }
    int main()
    {
        fun();
        return 0;
    }
```

  可以看到fun函数中pa ，pb之间互相引用，两个资源的引用计数为2，当要跳出函数时，智能指针pa，pb析构时两个资源引用计数会减一，但是两者引用计数还是为1，导致跳出函数时资源没有被释放（A B的析构函数没有被调用），如果把其中一个改为weak_ptr就可以了，我们把类A里面的shared_ptr pb_; 改为weak_ptr pb; 运行结果如下，这样的话，资源B的引用开始就只有1，当pb析构时，B的计数变为0，B得到释放，B释放的同时也会使A的计数减一，同时pa析构时使A的计数减一，那么A的计数为0，A得到释放。

  **注意**：我们不能通过weak_ptr直接访问对象的方法，比如B对象中有一个方法print()，我们不能这样访问，pa->pb*->print(); 英文pb*是一个weak_ptr，应该先把它转化为shared_ptr，如：shared_ptr p = pa->pb_.lock(); p->print();   

1. **线程安全性**

      多线程环境下，调用不同shared_ptr实例的成员函数是不需要额外的同步手段的，即使这些shared_ptr拥有的是同样的对象。但是如果多线程访问（有写操作）同一个shared_ptr，则需要同步，否则就会有race condition 发生。也可以使用 shared_ptr overloads of atomic functions来防止race condition的发生。

      多个线程同时读同一个shared_ptr对象是线程安全的，但是如果是多个线程对同一个shared_ptr对象进行读和写，则需要加锁。

      多线程读写shared_ptr所指向的同一个对象，不管是相同的shared_ptr对象，还是不同的shared_ptr对象，也需要加锁保护。例子如下：

    ```
    //程序实例
    shared_ptr<long> global_instance = make_shared<long>(0);
    std::mutex g_i_mutex;
     
    void thread_fcn()
    {
        //std::lock_guard<std::mutex> lock(g_i_mutex);
     
        //shared_ptr<long> local = global_instance;
     
        for(int i = 0; i < 100000000; i++)
        {
            *global_instance = *global_instance + 1;
            //*local = *local + 1;
        }
    }
     
    int main(int argc, char** argv)
    {
        thread thread1(thread_fcn);
        thread thread2(thread_fcn);
     
        thread1.join();
        thread2.join();
     
        cout << "*global_instance is " << *global_instance << endl;
     
        return 0;
    }
    ```

      在线程函数thread_fcn的for循环中，2个线程同时对global_instance进行加1的操作。这就是典型的非线程安全的场景，最后的结果是未定的，运行结果如下：

    ​      *global_instance is 197240539

      如果使用的是每个线程的局部shared_ptr对象local，因为这些local指向相同的对象，因此结果也是未定的，运行结果如下：      *global_instance is 160285803

      因此，这种情况下必须加锁，将thread_fcn中的第一行代码的注释去掉之后，不管是使用global_instance，还是使用local，得到的结果都是：

    ​      *global_instance is 200000000

#### 1.5.10 请你回答一下智能指针有没有内存泄露的情况

**参考回答**

  智能指针有内存泄露的情况发生。

1. 智能指针发生内存泄露的情况

      当两个对象同时使用一个shared_ptr成员变量指向对方，会造成循环引用，使引用计数失效，从而导致内存泄露。

2. 智能指针的内存泄漏如何解决？ 为了解决循环引用导致的内存泄漏，引入了弱指针weak_ptr，weak_ptr的构造函数不会修改引用计数的值，从而不会对对象的内存进行管理，其类似一个普通指针，但是不会指向引用计数的共享内存，但是可以检测到所管理的对象是否已经被释放，从而避免非法访问。

**答案解析**

```
//程序实例
#include <memory>
#include <iostream>
using namespace std;

class Child;
class Parent{
private:
    std::shared_ptr<Child> ChildPtr;
public:
    void setChild(std::shared_ptr<Child> child) {
        this->ChildPtr = child;
    }

    void doSomething() {
        if (this->ChildPtr.use_count()) {
        
        }
    }
    
    ~Parent() {
    
    }
};

class Child{
private:
    std::shared_ptr<Parent> ParentPtr;
public:
    void setPartent(std::shared_ptr<Parent> parent) {
        this->ParentPtr = parent;
    }
    void doSomething() {
        if (this->ParentPtr.use_count()) {
        
        }
    }
    ~Child() {
    }
};

int main() {
    std::weak_ptr<Parent> wpp;
    std::weak_ptr<Child> wpc;
    
    {
        std::shared_ptr<Parent>    p(new Parent);
        std::shared_ptr<Child> c(new Child);
        p->setChild(c);
        c->setPartent(p);
        wpp = p;
        wpc = c;
        std::cout << p.use_count() << std::endl;
        std::cout << c.use_count() << std::endl;
    }
    std::cout << wpp.use_count() << std::endl;
    std::cout << wpc.use_count() << std::endl;
    return 0;
}
/*    
    程序运行结果：
        2
        2
        1
        1
*/
```

  上述代码中，parent有一个shared_ptr类型的成员指向孩子，而child也有一个shared_ptr类型的成员指向父亲。然后在创建孩子和父亲对象时也使用了智能指针c和p，随后将c和p分别又赋值给child的智能指针成员parent和parent的智能指针成员child。从而形成了一个循环引用。

#### 1.5.11 简述一下 C++11 中四种类型转换

**参考回答**

  C++中四种类型转换分别为**const_cast、static_cast、dynamic_cast、reinterpret_cast**，四种转换功能分别如下：

1. const_cast

​    将const变量转为非const

1. static_cast

      最常用，可以用于各种隐式转换，比如非const转const，static_cast可以用于类向上转换，但向下转换能成功但是不安全。

2. dynamic_cast

      只能用于含有虚函数的类转换，用于类向上和向下转换

    ​      **向上转换：**指子类向基类转换。  

    ​      **向下转换：**指基类向子类转换。

    ​      这两种转换，子类包含父类，当父类转换成子类时可能出现非法内存访问的问题。

      dynamic_cast通过判断变量运行时类型和要转换的类型是否相同来判断是否能够进行向下转换。dynamic_cast可以做类之间上下转换，转换的时候会进行类型检查，类型相等成功转换，类型不等转换失败。运用RTTI技术，RTTI是”Runtime Type Information”的缩写，意思是运行时类型信息，它提供了运行时确定对象类型的方法。在c++层面主要体现在dynamic_cast和typeid，vs中虚函数表的-1位置存放了指向type_info的指针，对于存在虚函数的类型，dynamic_cast和typeid都会去查询type_info。

  \4. reinterpret_cast

​      reinterpret_cast可以做任何类型的转换，不过不对转换结果保证，容易出问题。

**注意：**为什么不用C的强制转换：C的强制转换表面上看起来功能强大什么都能转，但是转换不够明确，不能进行错误检查，容易出错。

#### 1.5.12 简述一下 C++ 11 中 auto 的具体用法

**参考回答**

  auto用于定义变量，编译器可以自动判断变量的类型。auto主要有以下几种用法：

1. auto的基本使用方法

    （1）基本使用语法如下

```
auto name = value; //name 是变量的名字，value 是变量的初始值
```

  **注意：**auto 仅仅是一个占位符，在编译器期间它会被真正的类型所替代。或者说，C++ 中的变量必须是有明确类型的，只是这个类型是由编译器自己推导出来的。

  （2）程序实例如下

```
auto n = 10; 
auto f = 12.8; 
auto p = &n; 
auto url = "www.123.com";
```

​      a. 第 1 行中，10 是一个整数，默认是 int 类型，所以推导出变量 n 的类型是 int。

​      b. 第 2 行中，12.8 是一个小数，默认是 double 类型，所以推导出变量 f 的类型是 double。

​      c. 第 3 行中，&n 的结果是一个 int* 类型的指针，所以推导出变量 f 的类型是 int*。

​      d. 第 4 行中，由双引号""包围起来的字符串是 const char* 类型，所以推导出变量 url 的类型是 const char*，也即一个常量指针。

1. auto和 const 的结合使用

    （1） auto 与 const 结合的用法

    ​    a. 当类型不为引用时，auto 的推导结果将不保留表达式的 const 属性；

    ​    b. 当类型为引用时，auto 的推导结果将保留表达式的 const 属性。

    （2）程序实例如下

```
int  x = 0;
const  auto n = x;  //n 为 const int ，auto 被推导为 int
auto f = n;      //f 为 const int，auto 被推导为 int（const 属性被抛弃）
const auto &r1 = x;  //r1 为 const int& 类型，auto 被推导为 int
auto &r2 = r1;  //r1 为 const int& 类型，auto 被推导为 const int 类型
```

​      a. 第 2 行代码中，n 为 const int，auto 被推导为 int。

​      b. 第 3 行代码中，n 为 const int 类型，但是 auto 却被推导为 int 类型，这说明当=右边的表达式带有 const 属性时，auto 不会  使用 const 属性，而是直接推导出 non-const 类型。

​      c. 第 4 行代码中，auto 被推导为 int 类型，这个很容易理解，不再赘述。

​      d. 第 5 行代码中，r1 是 const int & 类型，auto 也被推导为 const int 类型，这说明当 const 和引用结合时，auto 的推导将保留  表达式的 const 类型。

1. 使用auto定义迭代器

      在使用 stl 容器的时候，需要使用迭代器来遍历容器里面的元素；不同容器的迭代器有不同的类型，在定义迭代器时必须指明。而迭代器的类型有时候比较复杂，请看下面的例子：

```
#include <vector>
using namespace std;
int main(){
    vector< vector<int> > v;
    //vector< vector<int> >::iterator i = v.begin();
    auto i = v.begin();  //使用 auto 代替具体的类型,该句比上一句简洁,根据表达式 v.begin() 的类型（begin() 函数的返回值类型）来推导出变量i的类型
    return 0;
}
```

1. 用于泛型编程

      auto 的另一个应用就是当我们不知道变量是什么类型，或者不希望指明具体类型的时候，比如泛型编程中。请看下面例子：

```
#include <iostream>
using namespace std;
class A{
public:
    static int get(void){
        return 100;
    }
};
class B{
public:
    static const char* get(void){
        return "www.123.com";
    }
};
template <typename T>
void func(void){
    auto val = T::get();
    cout << val << endl;
}
int main(void){
    func<A>();
    func<B>();
    return 0;
}

/*        
    运行结果：
        100
        www.123.com
*/
```

  本例中的模板函数 func() 会调用所有类的静态函数 get()，并对它的返回值做统一处理，但是 get() 的返回值类型并不一样，而且不能自动转换。这种要求在以前的 C++ 版本中实现起来非常的麻烦，需要额外增加一个模板参数，并在调用时手动给该模板参数赋值，用以指明变量 val 的类型。但是有了 auto 类型自动推导，编译器就根据 get() 的返回值自己推导出 val 变量的类型，就不用再增加一个模板参数了。

#### 1.5.13 简述一下 C++11 中的可变参数模板新特性

**参考回答**

  可变参数模板(variadic template)使得编程者能够创建这样的模板函数和模板类，即可接受可变数量的参数。例如要编写一个函数，它可接受任意数量的参数，参数的类型只需是cout能显示的即可，并将参数显示为用逗号分隔的列表。

```
int n = 14;
double x = 2.71828;
std::string mr = "Mr.String objects!";
show_list(n, x);
show_list(x*x, '!', 7, mr); //这里的目标是定义show_list()

/*    
    运行结果：
      14, 2.71828
      7.38905， !, 7, Mr.String objects!
*/    
```

  要创建可变参数模板，需要理解几个要点：

  （1）模板参数包（parameter pack）；

  （2）函数参数包；

  （3）展开（unpack）参数包；

  （4）递归。

#### 1.5.14 简述一下 C++11 中 Lambda 新特性

**参考回答**

1. 定义

    lambda 匿名函数很简单，可以套用如下的**语法格式**：

       ```c++
     [外部变量访问方式说明符] (参数) mutable noexcept/throw() -> 返回值类型     {      函数体;     };
       ```

    其中各部分的含义分别为：

    a. **[外部变量方位方式说明符]**   [ ] 方括号用于向编译器表明当前是一个 lambda 表达式，其不能被省略。在方括号内部，可以注明当前 lambda 函数的函数体中可以使用哪些“外部变量”。

      所谓外部变量，指的是和当前 lambda 表达式位于同一作用域内的所有局部变量。

    b. **(参数)**   和普通函数的定义一样，lambda 匿名函数也可以接收外部传递的多个参数。和普通函数不同的是，如果不需要传递参数，可以连同 () 小括号一起省略；

    c. **mutable**   此关键字可以省略，如果使用则之前的 () 小括号将不能省略（参数个数可以为 0）。默认情况下，对于以值传递方式引入的外部变量，不允许在 lambda 表达式内部修改它们的值（可以理解为这部分变量都是 const 常量）。而如果想修改它们，就必须使用 mutable 关键字。

      **注意:**对于以值传递方式引入的外部变量，lambda 表达式修改的是拷贝的那一份，并不会修改真正的外部变量；

    d. **noexcept/throw()**   可以省略，如果使用，在之前的 () 小括号将不能省略（参数个数可以为 0）。默认情况下，lambda 函数的函数体中可以抛出任何类型的异常。而标注 noexcept 关键字，则表示函数体内不会抛出任何异常；使用 throw() 可以指定 lambda 函数内部可以抛出的异常类型。

    e. **-> 返回值类型**   指明 lambda 匿名函数的返回值类型。值得一提的是，如果 lambda 函数体内只有一个 return 语句，或者该函数返回 void，则编译器可以自行推断出返回值类型，此情况下可以直接省略"-> 返回值类型"。

    f. **函数体**   和普通函数一样，lambda 匿名函数包含的内部代码都放置在函数体中。该函数体内除了可以使用指定传递进来的参数之外，还可以使用指定的外部变量以及全局范围内的所有全局变量。

2. 程序实例

```
#include <iostream>
#include <algorithm>
using namespace std;
int main()
{
    int num[4] = {4, 2, 3, 1};
    //对 a 数组中的元素进行排序
    sort(num, num+4, [=](int x, int y) -> bool{ return x < y; } );
    for(int n : num){
        cout << n << " ";
    }
    return 0;
}

/*    
    程序运行结果：
          1 2 3 4
*/            
```

